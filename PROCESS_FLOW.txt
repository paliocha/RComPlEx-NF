╔════════════════════════════════════════════════════════════════════════════╗
║  RComPlEx: Comparative Analysis of Plant Co-Expression Networks in R      ║
║                                                                            ║
║  Identifies conserved co-expressologs (orthologous genes with conserved   ║
║  co-expression patterns) across species with different life habits        ║
╚════════════════════════════════════════════════════════════════════════════╝

WHAT IS RComPlEx?
═══════════════════════════════════════════════════════════════════════════════

RComPlEx discovers multi-species gene cliques where:
  • Genes are ORTHOLOGOUS (share common evolutionary ancestor)
  • Genes are ALL PAIRWISE CO-EXPRESSED within each species
  • Co-expression relationships are CONSERVED across species
  • Cliques represent complete functional modules (every gene connected to
    every other gene in the co-expression network)

Key Innovation: Unlike simple orthology or pairwise co-expression analysis,
RComPlEx finds COMPLETE SUBGRAPHS (cliques) ensuring all genes in a module
are mutually coordinated, providing stronger evidence of functional conservation.

Biological Significance:
  • Annual vs Perennial Adaptation: Identifies life-habit-specific gene modules
  • Tissue Specialization: Discovers tissue-specific conserved networks
  • Functional Module Discovery: Finds tightly coordinated gene expression
  • Multi-Copy Handling: Naturally partitions paralogs into separate modules

═══════════════════════════════════════════════════════════════════════════════

PIPELINE EXECUTION FLOW
═══════════════════════════════════════════════════════════════════════════════

For each tissue (root, leaf):
  │
  ├─→ PREPARE_PAIR (parallelized for each species pair)
  │     ├─ Script: scripts/prepare_single_pair.R
  │     ├─ CPUs: 2 | Memory: 8 GB | Time: 15m | MaxForks: 20 | Label: low_mem
  │     ├─ Input: vst_hog.RDS (expression), N1_clean.RDS (orthologs)
  │     ├─ Actions:
  │     │   - Extract tissue-specific expression data for species pair
  │     │   - Filter ortholog groups to genes present in both species
  │     │   - Create working directory with aligned data structures
  │     ├─ Output: species1_expr.txt, species2_expr.txt, orthologs.RData
  │     └─ Publishes to: rcomplex_data/{tissue}/pairs/{pair_id}/
  │
  ├─→ RCOMPLEX_02_COMPUTE_SPECIES_NETWORKS (per species–tissue, runs once and reused)
  │     ├─ Script: scripts/rcomplex_02_compute_species_network.R
  │     ├─ CPUs: 24 (retry: 36) | Memory: 100 GB (retry: 200/350 GB) | Time: 24h
  │     ├─ MaxForks: 13 | MaxRetries: 3 | Label: high_mem
  │     ├─ Container: RComPlEx.sif (R 4.5.2 + Rfast for fast correlation)
  │     ├─ Biological Purpose:
  │     │   Build co-expression networks per species–tissue once, then reuse across pairs
  │     ├─ Actions:
  │     │   - Filter expression to genes that have an ortholog in any other species (ortholog-wide universe; matches original RComPlEx intent)
  │     │   - Calculate pairwise correlations (Spearman/Pearson)
  │     │   - Normalize: MR or CLR; apply density threshold (default top 3%)
  │     │   - Compute thresholds for signed and unsigned networks (unsigned for polarity)
  │     └─ Saves: 02_network_signed.RData, 02_network_unsigned.RData, species gene list
  │
  ├─→ RCOMPLEX_01_LOAD_FILTER (per pair)
  │     ├─ Script: scripts/rcomplex_01_load_filter.R
  │     ├─ CPUs: 2 | Memory: 8 GB | Time: 15m | MaxForks: 20 | Label: low_mem
  │     ├─ Input: Data from PREPARE_PAIR
  │     ├─ Output: 01_filtered_data.RData
  │     ├─ Actions:
  │     │   - Load expression and orthologs for the pair
  │     │   - Keep only orthologs where BOTH genes are expressed
  │     │   - Validate data consistency (no missing genes)
  │
  ├─→ RCOMPLEX_03_LOAD_AND_FILTER_NETWORKS (pair-specific filtering of precomputed nets)
  │     ├─ Script: scripts/rcomplex_03_load_and_filter_networks.R
  │     ├─ CPUs: 2 | Memory: 32 GB | Time: 2h | MaxForks: 20 | Label: low_mem
  │     ├─ Input: 01_filtered_data.RData + species network files (signed/unsigned)
  │     ├─ Actions:
  │     │   - Load precomputed species networks for both species in the pair
  │     │   - Subset matrices to the pair's shared ortholog genes
  │     │   - [OPTION B] Recalibrate density thresholds for pair-specific subnetworks:
  │     │       * Check if ortholog-wide threshold applies to pair-specific genes
  │     │       * If threshold exceeds pair max edge, recompute to maintain ~3% density
  │     │       * Ensures consistent network sparsity across heterogeneous pair sizes
  │     │   - Emit filtered signed and unsigned networks with calibrated thresholds
  │     │   - Output: 02_networks_signed.RData, 02_networks_unsigned.RData
  │
  ├─→ RCOMPLEX_04_NETWORK_COMPARISON (CHAINED INPUT) **CORE INNOVATION**
  │     ├─ Script: scripts/rcomplex_03_network_comparison.R
  │     ├─ CPUs: 12 (retry: 24) | Memory: 150 GB (retry: 300 GB) | Time: 24h
  │     ├─ MaxForks: 10 | MaxRetries: 2
  │     ├─ Label: Dynamically allocated (high compute)
  │     ├─ Container: RComPlEx.sif (R 4.5.2 + furrr for parallel processing)
  │     ├─ Error Strategy: Retry on OOM (exit 137)
  │     ├─ Input: Filtered signed networks from RCOMPLEX_03_LOAD_AND_FILTER_NETWORKS
  │     ├─ Output: 03_comparison.RData (03_{pair_id}.RData)
  │     ├─ Biological Purpose:
  │     │   TEST WHETHER CO-EXPRESSION RELATIONSHIPS ARE CONSERVED BETWEEN SPECIES
  │     │   This identifies orthologs that not only share ancestry but also
  │     │   maintain similar regulatory contexts and functional roles
  │     ├─ Actions:
  │     │   For EACH ortholog pair (geneA_sp1, geneB_sp2):
  │     │   
  │     │   1. Extract co-expression neighborhoods:
  │     │      - Sp1_neighbors: All genes co-expressed with geneA in Species1
  │     │      - Sp2_neighbors: All genes co-expressed with geneB in Species2
  │     │   
  │     │   2. Test neighborhood conservation (BIDIRECTIONAL):
  │     │      Direction 1 (Sp1 → Sp2):
  │     │        Q: Do Sp1 neighbors have orthologs that are Sp2 neighbors?
  │     │        - Count overlap of conserved co-expression relationships
  │     │        - Hypergeometric test: Is overlap greater than random?
  │     │      
  │     │      Direction 2 (Sp2 → Sp1):
  │     │        Q: Do Sp2 neighbors have orthologs that are Sp1 neighbors?
  │     │        - Ensures bidirectional conservation
  │     │        - Use minimum p-value (most conservative)
  │     │   
  │     │   3. Multiple testing correction:
  │     │      - Benjamini-Hochberg FDR correction (controls false discoveries)
  │     │      - Testing ~10,000 ortholog pairs: must control family-wise error
  │     │   
  │     │   4. Parallel processing across ortholog pairs (24 cores)
  │     │
  │     └─ Saves: comparison dataframe with 13 columns:
  │               OrthoGroup, Species1, Species2,
  │               Species1.neigh (neighborhood size),
  │               Species1.ortho.neigh (orthologous neighbors),
  │               Species1.neigh.overlap (conserved overlap),
  │               Species1.p.val (FDR-corrected),
  │               Species1.effect.size (enrichment),
  │               [Same 5 columns for Species2]
  │
  │     Hypergeometric Test Explained:
  │       P(X ≥ k) where:
  │         k = observed overlap of conserved co-expression
  │         Population = all possible ortholog pairs
  │         Successes = genes co-expressed in focal species
  │         Sample size = neighborhood size in query species
  │       Tests: Is the overlap significantly greater than random?

    ├─→ RCOMPLEX_04_NETWORK_COMPARISON_UNSIGNED (CHAINED INPUT, OPTIONAL)
      ├─ Script: scripts/rcomplex_03_network_comparison.R (flag: --unsigned TRUE)
      ├─ CPUs: 12 (retry: 24) | Memory: 150 GB (retry: 300 GB) | Time: 24h
      ├─ Label: Dynamically allocated (high compute)
      ├─ Input: Filtered unsigned networks from RCOMPLEX_03_LOAD_AND_FILTER_NETWORKS
      ├─ Output: 03_<pair_id>_unsigned.RData
        ├─ Purpose:
        │   Diagnostic path to assess magnitude-based support irrespective of sign
        └─ Notes:
            Feeds unsigned clique detection and polarity divergence analysis
  │
  └─→ RCOMPLEX_05_SUMMARY_STATS (CHAINED INPUT)
        ├─ Script: scripts/rcomplex_04_summary_stats.R
        ├─ CPUs: 4 | Memory: 16 GB | Time: 1h | MaxForks: 15
        ├─ Label: medium_mem
        ├─ Container: RComPlEx.sif (R 4.5.2 + ggplot2 for visualization)
        ├─ Input: 03_comparison.RData (03_{pair_id}.RData)
        ├─ Output: 04_summary_statistics.tsv + PNG plots
        ├─ Biological Purpose:
        │   Aggregate and visualize conservation statistics for downstream
        │   interpretation and clique detection
        ├─ Actions:
        │   - Compute per-gene conservation metrics:
        │     • Mean/median p-values across all gene's ortholog pairs
        │     • Effect sizes (enrichment of conserved neighborhoods)
        │   - Compute per-HOG (Hierarchical Ortholog Group) statistics:
        │     • Conservation across all genes in ortholog family
        │   - Generate diagnostic visualizations:
        │     • P-value correlation: Sp1→Sp2 vs Sp2→Sp1 (bidirectional agreement)
        │     • Effect size distribution: Strength of conservation signal
        │   - Create analysis-ready summary table
        ├─ Publishes to: rcomplex_data/{tissue}/results/{pair_id}/
        └─ Outputs:
            - 04_summary_statistics.tsv (full comparison table for cliques)
            - 04_pvalue_correlation.png (bidirectional test agreement)
            - 04_effect_size_plot.png (conservation signal strength)

After all species pairs complete for each tissue (SYNCHRONIZATION POINT):
  │
  ├─→ FIND_CLIQUES **KEY BIOLOGICAL OUTPUT**
  │     ├─ Script: scripts/find_coexpressolog_cliques.R
  │     ├─ CPUs: 12 | Memory: 280 GB | Time: 2d | MaxForks: 4
  │     ├─ Label: very_high_mem
  │     ├─ Container: RComPlEx.sif (R 4.5.2 + igraph::max_cliques)
  │     ├─ Input: ALL 03_comparison.RData files for tissue
  │     ├─ Biological Purpose:
  │     │   Identify COMPLETE GENE MODULES where ALL pairwise co-expression
  │     │   relationships are conserved. This is stronger evidence of functional
  │     │   conservation than individual gene pairs.
  │     ├─ Actions:
  │     │   
  │     │   1. Load all pairwise comparisons for tissue
  │     │      - Combine results from ALL species pair analyses
  │     │      - Filter to conserved pairs (p < 0.05 after FDR correction)
  │     │   
  │     │   2. For EACH Hierarchical Ortholog Group (HOG):
  │     │      a) Build undirected graph:
  │     │         - Nodes = genes from all species in the HOG
  │     │         - Edges = conserved co-expression relationships
  │     │      
  │     │      b) Find MAXIMAL CLIQUES using igraph::max_cliques():
  │     │         - Clique = complete subgraph (all nodes connected to all)
  │     │         - Maximal = cannot add more genes without losing completeness
  │     │         - Example: 4-gene clique has 6 edges (all pairs significant)
  │     │      
  │     │      c) Why cliques matter:
  │     │         - Handles many-to-many orthology naturally
  │     │         - Multiple cliques per HOG = different functional modules
  │     │         - Ensures COMPLETE coordination (not partial)
  │     │   
  │     │   3. Annotate cliques with biological metadata:
  │     │      - Species composition (which species represented)
  │     │      - Life habit classification:
  │     │        • Annual: All genes from annual species
  │     │        • Perennial: All genes from perennial species
  │     │        • Mixed: Both annual and perennial
  │     │      - Statistical properties:
  │     │        • Mean/median p-values (conservation strength)
  │     │        • Effect sizes (enrichment magnitude)
  │     │        • Number of edges (pairwise relationships)
  │     │   
  │     │   4. Stratify outputs by life habit for comparative analysis
  │     │
  │     └─ Outputs:
  │         - coexpressolog_cliques_{tissue}_all.tsv (all cliques)
  │         - coexpressolog_cliques_{tissue}_annual.tsv (annual-specific)
  │         - coexpressolog_cliques_{tissue}_perennial.tsv (perennial-specific)
  │         - coexpressolog_cliques_{tissue}_shared.tsv (mixed)
  │         - genes_{tissue}_annual.txt (gene lists for GO enrichment)
  │         - genes_{tissue}_perennial.txt
  │         - genes_{tissue}_mixed.txt
  │
  ├─→ FIND_CLIQUES_UNSIGNED (UNSIGNED PATH)
  │     ├─ Script: scripts/find_coexpressolog_cliques.R
  │     ├─ CPUs: 12 | Memory: 220 GB | Time: 2d
  │     ├─ Label: very_high_mem
  │     ├─ Input: ALL 03_<pair_id>_unsigned.RData files for tissue
  │     ├─ Purpose:
  │     │   Produce magnitude-based unsigned cliques and gene lists for comparison
  │     └─ Outputs:
  │         - coexpressolog_cliques_unsigned_{tissue}_all.tsv
  │         - coexpressolog_cliques_unsigned_{tissue}_annual.tsv
  │         - coexpressolog_cliques_unsigned_{tissue}_perennial.tsv
  │         - coexpressolog_cliques_unsigned_{tissue}_shared.tsv
  │         - genes_unsigned_{tissue}_annual.txt
  │         - genes_unsigned_{tissue}_perennial.txt
  │         - genes_unsigned_{tissue}_mixed.txt
  │
  ├─→ POLARITY_DIVERGENCE
  │     ├─ Script: scripts/polarity_divergence_report.R
  │     ├─ CPUs: 4 | Memory: 32 GB | Time: 4h
  │     ├─ Label: low_mem
  │     ├─ Input: Paired signed vs unsigned comparison artifacts (joined by tissue and pair_id)
  │     ├─ Purpose:
  │     │   Flag edges with polarity mismatch but strong unsigned support (Q3 threshold)
  │     └─ Output: results/{tissue}/polarity/polarity_divergence_<pair_id>.tsv
  │
  │     Clique Detection Algorithm:
  │       • igraph::max_cliques() - finds all maximal complete subgraphs
  │       • Guarantees: Every gene pair in clique has p < 0.05
  │       • Biological significance: Entire module is co-regulated
  │
  └─→ SUMMARY_REPORT
        ├─ Script: Nextflow process (inline bash)
        ├─ CPUs: 2 | Memory: 500 GB | Time: 24h | MaxForks: 8
        ├─ Label: high_mem
        ├─ Input: All clique TSV files
        ├─ Actions:
        │   - Count cliques per tissue and life habit
        │   - Count genes in each category
        │   - Generate human-readable summary
        └─ Output: pipeline_summary.txt (final report)

═══════════════════════════════════════════════════════════════════════════════

DEPENDENCY CHAIN
═══════════════════════════════════════════════════════════════════════════════

01_filtered_data.RData
      ↓
      contains: ortho, species1_expr, species2_expr
      
02_networks.RData
      ↓ (requires 01_filtered_data.RData for gene counts)
      contains: species1_net, species2_net, thresholds
      
03_comparison.RData
      ↓ (requires both 01 and 02)
      contains: comparison dataframe with 13 columns:
                OrthoGroup, Species1, Species2,
                Species1.neigh, Species1.ortho.neigh, Species1.neigh.overlap,
                Species1.p.val, Species1.effect.size,
                Species2.neigh, Species2.ortho.neigh, Species2.neigh.overlap,
                Species2.p.val, Species2.effect.size
      
04_summary_statistics.tsv
      ↓ (requires 03)
      contains: Full comparison table ready for downstream analysis
      
      png plots
      ↓
      contains: Visualizations of results

═══════════════════════════════════════════════════════════════════════════════

RESOURCE ALLOCATION SUMMARY
═══════════════════════════════════════════════════════════════════════════════

Process                                  CPUs    Memory      Time    MaxForks  Retries
──────────────────────────────────────────────────────────────────────────────────────
PREPARE_PAIR                             2       8 GB        15m     20        -
RCOMPLEX_01_LOAD_FILTER                  2       8 GB        15m     20        -
RCOMPLEX_02_COMPUTE_SPECIES_NETWORKS     24→36   100→350 GB   24h     13        3
RCOMPLEX_03_LOAD_AND_FILTER_NETWORKS     2       32 GB       2h      20        -
RCOMPLEX_04_NETWORK_COMPARISON           12→24   150→300 GB  24h     10        2
RCOMPLEX_04_NETWORK_COMPARISON_UNSIGNED  12→24   150→300 GB  24h     10        2
RCOMPLEX_05_SUMMARY_STATS                4       16 GB       1h      15        -
FIND_CLIQUES                             12      280 GB      2d      4         -
SUMMARY_REPORT                           2       500 GB      24h     8         -

Resource Labels:
  - low_mem:       2 CPUs, 8 GB, 30m, maxForks=30
  - medium_mem:    4 CPUs, 16 GB, 2h, maxForks=15
  - high_mem:      2 CPUs, 500 GB, 24h, maxForks=8
  - very_high_mem: 12 CPUs, 280 GB, 2d, maxForks=4

Optimizations (from original implementation):
  ✓ Increased CPUs for steps 2-3 (24 → 24/12 with 48/24 retry)
  ✓ Reduced memory for step 2 (280 → 200 GB, R is CPU-bound)
  ✓ Increased maxForks (5→10 for high compute steps)
  ✓ Added automatic retry on OOM (exit 137)
  ✓ Dynamic resource scaling on retry attempts

Total per pair peak: 24-48 CPUs, 200-400 GB memory during steps 2-3
With 100 pairs per tissue × 2 tissues = 200 concurrent pair-level operations
Parallelization controlled by maxForks to prevent cluster overload

═══════════════════════════════════════════════════════════════════════════════

CONTAINER AND EXECUTION ENVIRONMENT
═══════════════════════════════════════════════════════════════════════════════

Container: RComPlEx.sif
  - Base Image: rocker/tidyverse:4.5.2
  - R Version: 4.5.2
  - Key Packages: tidyverse, igraph, furrr, future, data.table, Rfast,
                  matrixStats, gplots, RColorBrewer, cowplot, DT, optparse,
                  yaml, glue, conflicted
  - System Libraries: gsl, gfortran, OpenBLAS, LAPACK
  - Optional: WGCNA (for alternative correlation methods)

Singularity Configuration:
  - Enabled: Yes (all processes use container)
  - Cache Directory: /local/genome/packages/singularity/CACHE/nextflow
  - Run Options: --bind $TMPDIR:/tmp --no-home --containall
  - Auto Mount: Yes (filesystem access)
  - Stage In Mode: copy (safer for parallel access)
  - Stage Out Mode: move (faster output)

SLURM Configuration:
  - Executor: slurm
  - Queue: orion
  - Account: nmbu
  - Scratch: Enabled (local scratch for I/O performance)
  - Module: singularity (loaded before each job)

Profiles Available:
  - slurm: Production HPC with container (default)
  - standard: Local execution without SLURM
  - test: Test mode with limited pairs (--test_mode true)

═══════════════════════════════════════════════════════════════════════════════

MONITORING AND DEBUGGING
═══════════════════════════════════════════════════════════════════════════════

Watch progress:
  nextflow run main.nf -profile slurm -with-timeline timeline.html \
                        -with-report report.html -with-trace trace.txt

Check logs:
  .nextflow/logs/  (overall execution logs)
  tail -f .nextflow.log  (live monitoring)

Check work directory:
  .nextflow/work/XX/YYYYYY/  (per-process directories)
  ls work/*/*/.command.{sh,log,err,out}  (inspect job files)

Check SLURM jobs:
  squeue -u $USER  (see running/pending jobs)
  sacct -j JOBID --format=JobID,JobName,State,ExitCode,MaxRSS,Elapsed

Inspect intermediate results:
  # Load R data files
  R console: load("work/XX/YYYYYY/01_filtered_data.RData")
  R console: head(ortho)
  R console: dim(species1_net)
  
  # Check process output
  cat work/XX/YYYYYY/.command.log
  cat work/XX/YYYYYY/.command.err

Final results location:
  rcomplex_data/{tissue}/results/{pair_id}/
    ├── 04_summary_statistics.tsv
    ├── 04_pvalue_correlation.png
    └── 04_effect_size_plot.png
  
  results/
    ├── coexpressolog_cliques_{tissue}_all.tsv
    ├── coexpressolog_cliques_{tissue}_annual.tsv
    ├── coexpressolog_cliques_{tissue}_perennial.tsv
    ├── coexpressolog_cliques_{tissue}_shared.tsv
    ├── coexpressolog_cliques_unsigned_{tissue}_*.tsv
    ├── genes_unsigned_{tissue}_*.txt
    ├── {tissue}/polarity/polarity_divergence_<pair_id>.tsv
    └── pipeline_summary.txt

═══════════════════════════════════════════════════════════════════════════════

ERROR RECOVERY
═══════════════════════════════════════════════════════════════════════════════

Automatic Retry Mechanisms:
  - Steps 2 & 3 have automatic retry on OOM (exit 137)
  - Retry with increased resources (2x CPUs, 2x memory)
  - Max retries: 2 attempts per task

If Step 2 (COMPUTE_NETWORKS) fails:
  1. Check error in work directory:
     cat work/XX/YYYYYY/.command.err
  2. Common issues:
     - OOM (exit 137): Will auto-retry with more memory
     - Data corruption: Check 01_filtered_data.RData
     - Correlation computation failure: Check R package versions
  3. Resume pipeline:
     nextflow run main.nf -profile slurm -resume
  4. Nextflow will re-run failed tasks and cascade to 3, 4

If Step 3 (NETWORK_COMPARISON) fails:
  1. Check error message in work directory:
     cat work/XX/YYYYYY/.command.err
     cat work/XX/YYYYYY/.command.log
  2. Common issues:
     - OOM (exit 137): Will auto-retry with more memory
     - Missing orthologs: Check data consistency in step 1
     - Hypergeometric test failure: Check neighborhood sizes
  3. Manual re-run (if needed):
     apptainer exec RComPlEx.sif \
       Rscript scripts/rcomplex_03_network_comparison.R \
         --tissue root --pair_id Species1_Species2 \
         --workdir . --indir work/XX/YYYYYY --outdir . --cores 12
  4. Resume pipeline:
     nextflow run main.nf -profile slurm -resume

If FIND_CLIQUES fails:
  1. Check memory usage (requires 280 GB)
  2. Verify all 03_comparison.RData files exist
  3. Check igraph installation in container
  4. Resume with: nextflow run main.nf -profile slurm -resume

General Debugging Strategy:
  1. Find failed task work directory: .nextflow/work/XX/YYYYYY/
  2. Check SLURM logs: .command.log, .command.err
  3. Inspect input data: load RData files in R console
  4. Check resource usage: sacct -j JOBID --format=MaxRSS,Elapsed
  5. Fix issue and resume: nextflow run main.nf -resume
  6. Always use -resume to avoid re-running successful tasks

═══════════════════════════════════════════════════════════════════════════════
