╔════════════════════════════════════════════════════════════════════════════╗
║  RComPlEx: Comparative Analysis of Plant Co-Expression Networks in R      ║
║                                                                            ║
║  Identifies conserved co-expressologs (orthologous genes with conserved   ║
║  co-expression patterns) across species with different life habits        ║
╚════════════════════════════════════════════════════════════════════════════╝

WHAT IS RComPlEx?
═══════════════════════════════════════════════════════════════════════════════

RComPlEx discovers multi-species gene cliques where:
  • Genes are ORTHOLOGOUS (share common evolutionary ancestor)
  • Genes are ALL PAIRWISE CO-EXPRESSED within each species
  • Co-expression relationships are CONSERVED across species
  • Cliques represent complete functional modules (every gene connected to
    every other gene in the co-expression network)

Key Innovation: Unlike simple orthology or pairwise co-expression analysis,
RComPlEx finds COMPLETE SUBGRAPHS (cliques) ensuring all genes in a module
are mutually coordinated, providing stronger evidence of functional conservation.

Biological Significance:
  • Annual vs Perennial Adaptation: Identifies life-habit-specific gene modules
  • Tissue Specialization: Discovers tissue-specific conserved networks
  • Functional Module Discovery: Finds tightly coordinated gene expression
  • Multi-Copy Handling: Naturally partitions paralogs into separate modules

═══════════════════════════════════════════════════════════════════════════════

PIPELINE EXECUTION FLOW
═══════════════════════════════════════════════════════════════════════════════

For each tissue (root, leaf):
  │
  ├─→ PREPARE_PAIR (parallelized for each species pair)
  │     ├─ Script: scripts/prepare_single_pair.R
  │     ├─ CPUs: 2 | Memory: 8 GB | Time: 15m | MaxForks: 20 | Label: low_mem
  │     ├─ Input: vst_hog.RDS (expression), N1_clean.RDS (orthologs)
  │     ├─ Actions:
  │     │   - Extract tissue-specific expression data for species pair
  │     │   - Filter ortholog groups to genes present in both species
  │     │   - Create working directory with aligned data structures
  │     ├─ Output: species1_expr.txt, species2_expr.txt, orthologs.RData
  │     └─ Publishes to: rcomplex_data/{tissue}/pairs/{pair_id}/
  │
  ├─→ RCOMPLEX_02_COMPUTE_SPECIES_NETWORKS (per species–tissue, runs once and reused)
  │     ├─ Script: scripts/rcomplex_02_compute_species_network.R
  │     ├─ CPUs: 24 (retry: 36) | Memory: 100 GB (retry: 200/350 GB) | Time: 24h
  │     ├─ MaxForks: 13 | MaxRetries: 3 | Label: high_mem
  │     ├─ Container: RComPlEx.sif (R 4.5.2 + Rfast for fast correlation)
  │     ├─ Biological Purpose:
  │     │   Build co-expression networks per species–tissue once, then reuse across pairs
  │     ├─ Actions:
  │     │   - Filter expression to genes that have an ortholog in any other species (ortholog-wide universe; matches original RComPlEx intent)
  │     │   - Calculate pairwise correlations (Spearman/Pearson)
  │     │   - Normalize: MR or CLR; apply density threshold (default top 3%)
  │     │   - Compute thresholds for signed and unsigned networks (unsigned for polarity)
  │     └─ Saves: 02_network_signed.RData, 02_network_unsigned.RData, species gene list
  │
  ├─→ RCOMPLEX_01_LOAD_FILTER (per pair)
  │     ├─ Script: scripts/rcomplex_01_load_filter.R
  │     ├─ CPUs: 2 | Memory: 8 GB | Time: 15m | MaxForks: 20 | Label: low_mem
  │     ├─ Input: Data from PREPARE_PAIR
  │     ├─ Output: 01_filtered_data.RData
  │     ├─ Actions:
  │     │   - Load expression and orthologs for the pair
  │     │   - Keep only orthologs where BOTH genes are expressed
  │     │   - Validate data consistency (no missing genes)
  │
  ├─→ RCOMPLEX_03_LOAD_AND_FILTER_NETWORKS (pair-specific filtering of precomputed nets)
  │     ├─ Script: scripts/rcomplex_03_load_and_filter_networks.R
  │     ├─ CPUs: 2 | Memory: 32 GB | Time: 2h | MaxForks: 20 | Label: low_mem
  │     ├─ Input: 01_filtered_data.RData + species network files (signed/unsigned)
  │     ├─ Actions:
  │     │   - Load precomputed species networks for both species in the pair
  │     │   - Subset matrices to the pair's shared ortholog genes
  │     │   - [OPTION B] Recalibrate density thresholds for pair-specific subnetworks:
  │     │       * Check if ortholog-wide threshold applies to pair-specific genes
  │     │       * If threshold exceeds pair max edge, recompute to maintain ~3% density
  │     │       * Ensures consistent network sparsity across heterogeneous pair sizes
  │     │   - Emit filtered signed and unsigned networks with calibrated thresholds
  │     │   - Output: 02_networks_signed.RData, 02_networks_unsigned.RData
  │
  ├─→ RCOMPLEX_04_NETWORK_COMPARISON (CHAINED INPUT) **CORE INNOVATION**
  │     ├─ Script: scripts/rcomplex_03_network_comparison.R
  │     ├─ CPUs: 12 (retry: 24) | Memory: 150 GB (retry: 300 GB) | Time: 24h
  │     ├─ MaxForks: 10 | MaxRetries: 2
  │     ├─ Label: Dynamically allocated (high compute)
  │     ├─ Container: RComPlEx.sif (R 4.5.2 + furrr for parallel processing)
  │     ├─ Error Strategy: Retry on OOM (exit 137)
  │     ├─ Input: Filtered signed networks from RCOMPLEX_03_LOAD_AND_FILTER_NETWORKS
  │     ├─ Output: 03_comparison.RData (03_{pair_id}.RData)
  │     ├─ Biological Purpose:
  │     │   TEST WHETHER CO-EXPRESSION RELATIONSHIPS ARE CONSERVED BETWEEN SPECIES
  │     │   This identifies orthologs that not only share ancestry but also
  │     │   maintain similar regulatory contexts and functional roles
  │     ├─ Actions:
  │     │   For EACH ortholog pair (geneA_sp1, geneB_sp2):
  │     │   
  │     │   1. Extract co-expression neighborhoods:
  │     │      - Sp1_neighbors: All genes co-expressed with geneA in Species1
  │     │      - Sp2_neighbors: All genes co-expressed with geneB in Species2
  │     │   
  │     │   2. Test neighborhood conservation (BIDIRECTIONAL):
  │     │      Direction 1 (Sp1 → Sp2):
  │     │        Q: Do Sp1 neighbors have orthologs that are Sp2 neighbors?
  │     │        - Count overlap of conserved co-expression relationships
  │     │        - Hypergeometric test: Is overlap greater than random?
  │     │      
  │     │      Direction 2 (Sp2 → Sp1):
  │     │        Q: Do Sp2 neighbors have orthologs that are Sp1 neighbors?
  │     │        - Ensures bidirectional conservation
  │     │        - Use minimum p-value (most conservative)
  │     │   
  │     │   3. Multiple testing correction:
  │     │      - Benjamini-Hochberg FDR correction (controls false discoveries)
  │     │      - Testing ~10,000 ortholog pairs: must control family-wise error
  │     │   
  │     │   4. Parallel processing across ortholog pairs (24 cores)
  │     │
  │     └─ Saves: comparison dataframe with 13 columns:
  │               OrthoGroup, Species1, Species2,
  │               Species1.neigh (neighborhood size),
  │               Species1.ortho.neigh (orthologous neighbors),
  │               Species1.neigh.overlap (conserved overlap),
  │               Species1.p.val (FDR-corrected),
  │               Species1.effect.size (enrichment),
  │               [Same 5 columns for Species2]
  │
  │     Hypergeometric Test Explained:
  │       P(X ≥ k) where:
  │         k = observed overlap of conserved co-expression
  │         Population = all possible ortholog pairs
  │         Successes = genes co-expressed in focal species
  │         Sample size = neighborhood size in query species
  │       Tests: Is the overlap significantly greater than random?

    ├─→ RCOMPLEX_04_NETWORK_COMPARISON_UNSIGNED (CHAINED INPUT, OPTIONAL)
      ├─ Script: scripts/rcomplex_03_network_comparison.R (flag: --unsigned TRUE)
      ├─ CPUs: 12 (retry: 24) | Memory: 150 GB (retry: 300 GB) | Time: 24h
      ├─ Label: Dynamically allocated (high compute)
      ├─ Input: Filtered unsigned networks from RCOMPLEX_03_LOAD_AND_FILTER_NETWORKS
      ├─ Output: 03_<pair_id>_unsigned.RData
        ├─ Purpose:
        │   Diagnostic path to assess magnitude-based support irrespective of sign
        └─ Notes:
            Feeds unsigned clique detection and polarity divergence analysis
  │
  └─→ RCOMPLEX_05_SUMMARY_STATS (CHAINED INPUT)
        ├─ Script: scripts/rcomplex_04_summary_stats.R
        ├─ CPUs: 4 | Memory: 16 GB | Time: 1h | MaxForks: 15
        ├─ Label: medium_mem
        ├─ Container: RComPlEx.sif (R 4.5.2 + ggplot2 for visualization)
        ├─ Input: 03_comparison.RData (03_{pair_id}.RData)
        ├─ Output: 04_summary_statistics.tsv + PNG plots
        ├─ Biological Purpose:
        │   Aggregate and visualize conservation statistics for downstream
        │   interpretation and clique detection
        ├─ Actions:
        │   - Compute per-gene conservation metrics:
        │     • Mean/median p-values across all gene's ortholog pairs
        │     • Effect sizes (enrichment of conserved neighborhoods)
        │   - Compute per-HOG (Hierarchical Ortholog Group) statistics:
        │     • Conservation across all genes in ortholog family
        │   - Generate diagnostic visualizations:
        │     • P-value correlation: Sp1→Sp2 vs Sp2→Sp1 (bidirectional agreement)
        │     • Effect size distribution: Strength of conservation signal
        │   - Create analysis-ready summary table
        ├─ Publishes to: rcomplex_data/{tissue}/results/{pair_id}/
        └─ Outputs:
            - 04_summary_statistics.tsv (full comparison table for cliques)
            - 04_pvalue_correlation.png (bidirectional test agreement)
            - 04_effect_size_plot.png (conservation signal strength)

After all species pairs complete for each tissue (SYNCHRONIZATION POINT):
  │
  ├─→ FIND_CLIQUES_STREAMING **KEY BIOLOGICAL OUTPUT** (Memory-Efficient Design)
  │     ├─ Script: scripts/find_cliques_streaming.R
  │     ├─ CPUs: 4 | Memory: 64→128→256 GB (retry scaling) | Time: 24h
  │     ├─ MaxForks: 4 | MaxRetries: 2 | Label: high_mem
  │     ├─ Container: RComPlEx.sif (R 4.5.2 + igraph::max_cliques + qs2)
  │     ├─ Input: ALL 03_comparison.RData files for tissue + N1_clean.RDS orthologs
  │     ├─ Modes: 'signed' (default) or 'unsigned' (when --run_unsigned enabled)
  │     │
  │     ├─ Biological Purpose:
  │     │   Identify COMPLETE GENE MODULES where ALL pairwise co-expression
  │     │   relationships are conserved. This is stronger evidence of functional
  │     │   conservation than individual gene pairs.
  │     │
  │     ├─ Algorithm: TWO-PASS STREAMING (Memory Efficient)
  │     │   
  │     │   Pass 1: Build HOG→Files Index (lightweight scan)
  │     │     - Scan all 03_comparison.RData files
  │     │     - Extract unique HOGs from each file
  │     │     - Build index mapping each HOG to its containing files
  │     │     - No expression data loaded; only metadata
  │     │   
  │     │   Pass 2: Process HOGs One-by-One (sequential, bounded memory)
  │     │     For EACH unique HOG:
  │     │       a) Load ONLY data for this specific HOG from relevant files
  │     │       b) Build undirected graph:
  │     │          - Nodes = genes from all species in the HOG
  │     │          - Edges = conserved co-expression (p < 0.05)
  │     │       c) Find maximal cliques using igraph::max_cliques()
  │     │       d) Annotate with species composition and life habit
  │     │       e) Write results immediately (streaming output)
  │     │       f) Clear memory before processing next HOG
  │     │   
  │     │   Advantages over batch loading:
  │     │     ✓ Constant memory usage regardless of dataset size
  │     │     ✓ Processes 10,000+ HOGs without OOM
  │     │     ✓ Natural checkpointing (can resume per-HOG)
  │     │
  │     ├─ Clique Detection Algorithm:
  │     │   • igraph::max_cliques() - finds all maximal complete subgraphs
  │     │   • Clique = complete subgraph (all nodes connected to all)
  │     │   • Maximal = cannot add more genes without losing completeness
  │     │   • Example: 4-gene clique has 6 edges (all pairs significant)
  │     │   • Guarantees: Every gene pair in clique has p < 0.05
  │     │   • Biological significance: Entire module is co-regulated
  │     │
  │     ├─ Clique Annotation:
  │     │   - Species composition (which species represented)
  │     │   - Life habit classification:
  │     │     • Annual: All genes from annual species
  │     │     • Perennial: All genes from perennial species
  │     │     • Mixed: Both annual and perennial
  │     │   - Statistical properties:
  │     │     • Mean/median p-values (conservation strength)
  │     │     • Effect sizes (enrichment magnitude)
  │     │     • Number of edges (pairwise relationships)
  │     │
  │     └─ Outputs (publishDir: results/{tissue}/):
  │         - cliques.qs2 (fast qs2 serialization for R)
  │         - cliques.csv (portable CSV format)
  │         - cliques_annual.csv (annual-specific cliques)
  │         - cliques_perennial.csv (perennial-specific cliques)
  │         - cliques_shared.csv (mixed life habits)
  │         (Unsigned mode: cliques_unsigned.qs2, cliques_unsigned_*.csv)
  │
  ├─→ POLARITY_DIVERGENCE (OPTIONAL - when --run_unsigned enabled)
  │     ├─ Script: scripts/polarity_divergence_report.R
  │     ├─ CPUs: 4 | Memory: 200→400→600 GB (retry scaling) | Time: 72h
  │     ├─ MaxForks: 10 | MaxRetries: 2 | Label: low_mem
  │     ├─ Input: Paired signed vs unsigned comparison files (joined by tissue and pair_id)
  │     ├─ Purpose:
  │     │   Flag edges with polarity mismatch but strong unsigned support
  │     │   Identifies potential regulatory polarity changes between species
  │     │   (genes that are co-expressed in magnitude but have opposite correlation signs)
  │     └─ Output: results/{tissue}/polarity/polarity_divergence_{pair_id}.tsv
  │
  └─→ [REMOVED] SUMMARY_REPORT
        │   Functionality integrated into FIND_CLIQUES_STREAMING
        │   Summary statistics computed inline during clique detection
        └─ Summary output now embedded in clique annotation

═══════════════════════════════════════════════════════════════════════════════

DEPENDENCY CHAIN
═══════════════════════════════════════════════════════════════════════════════

01_filtered_data.RData
      ↓
      contains: ortho, species1_expr, species2_expr
      
02_networks.RData
      ↓ (requires 01_filtered_data.RData for gene counts)
      contains: species1_net, species2_net, thresholds
      
03_comparison.RData
      ↓ (requires both 01 and 02)
      contains: comparison dataframe with 13 columns:
                OrthoGroup, Species1, Species2,
                Species1.neigh, Species1.ortho.neigh, Species1.neigh.overlap,
                Species1.p.val, Species1.effect.size,
                Species2.neigh, Species2.ortho.neigh, Species2.neigh.overlap,
                Species2.p.val, Species2.effect.size
      
04_summary_statistics.tsv
      ↓ (requires 03)
      contains: Full comparison table ready for downstream analysis
      
      png plots
      ↓
      contains: Visualizations of results

═══════════════════════════════════════════════════════════════════════════════

RESOURCE ALLOCATION SUMMARY
═══════════════════════════════════════════════════════════════════════════════

Process                                  CPUs    Memory         Time    MaxForks  Retries
────────────────────────────────────────────────────────────────────────────────────────
PREPARE_PAIR                             2       8 GB           15m     20        -
RCOMPLEX_01_LOAD_FILTER                  2       8 GB           15m     20        -
RCOMPLEX_02_COMPUTE_SPECIES_NETWORKS     24→36   100→350 GB     24h     13        3
RCOMPLEX_03_LOAD_AND_FILTER_NETWORKS     2       32 GB          2h      20        -
RCOMPLEX_03_LOAD_AND_FILTER_NETWORKS_U   2       32 GB          2h      20        - (unsigned)
RCOMPLEX_04_NETWORK_COMPARISON           12→24   150→300 GB     24h     10        2
RCOMPLEX_04_NETWORK_COMPARISON_UNSIGNED  12→24   150→300 GB     24h     10        2
RCOMPLEX_05_SUMMARY_STATS                4       16 GB          1h      15        -
FIND_CLIQUES_STREAMING                   4       64→256 GB      24h     4         2
POLARITY_DIVERGENCE                      4       200→600 GB     72h     10        2

Total Processes: 10 (7 in default mode, +3 when --run_unsigned enabled)

Resource Labels (defined in nextflow.config):
  - low_mem:       2 CPUs, 8 GB, 30m, maxForks=30
  - medium_mem:    4 CPUs, 16 GB, 2h, maxForks=15
  - high_mem:      4 CPUs, 64 GB (→128→256 on retry), 24h, maxForks=4
  - very_high_mem: 12 CPUs, 280 GB, 2d, maxForks=4

Memory Retry Scaling:
  - RCOMPLEX_02: 100 GB → 200 GB → 350 GB
  - RCOMPLEX_04: 150 GB → 300 GB
  - FIND_CLIQUES_STREAMING: 64 GB → 128 GB → 256 GB
  - POLARITY_DIVERGENCE: 200 GB → 400 GB → 600 GB

Optimizations (from original implementation):
  ✓ Two-pass streaming clique detection (constant memory per HOG)
  ✓ Per-species network computation (reused across pairs)
  ✓ qs2 serialization for fast inter-process data transfer
  ✓ Automatic retry on OOM (exit 137) with resource scaling
  ✓ Dynamic maxForks to prevent cluster overload

Peak Resource Usage:
  - Per-pair steps: 24-48 CPUs, 200-400 GB during RCOMPLEX_02/04
  - Final clique detection: 4 CPUs, 64-256 GB per tissue
  - With 100 pairs per tissue × 2 tissues = 200 concurrent pair-level operations
  - Parallelization controlled by maxForks

═══════════════════════════════════════════════════════════════════════════════

CONTAINER AND EXECUTION ENVIRONMENT
═══════════════════════════════════════════════════════════════════════════════

Container: RComPlEx.sif
  - Base Image: rocker/tidyverse:4.5.2
  - R Version: 4.5.2
  - Key Packages: tidyverse, igraph, furrr, future, data.table, Rfast,
                  matrixStats, gplots, RColorBrewer, cowplot, DT, optparse,
                  yaml, glue, conflicted
  - System Libraries: gsl, gfortran, OpenBLAS, LAPACK
  - Optional: WGCNA (for alternative correlation methods)

Singularity Configuration:
  - Enabled: Yes (all processes use container)
  - Cache Directory: /local/genome/packages/singularity/CACHE/nextflow
  - Run Options: --bind $TMPDIR:/tmp --no-home --containall
  - Auto Mount: Yes (filesystem access)
  - Stage In Mode: copy (safer for parallel access)
  - Stage Out Mode: move (faster output)

SLURM Configuration:
  - Executor: slurm
  - Queue: orion
  - Account: nmbu
  - Scratch: Enabled (local scratch for I/O performance)
  - Module: singularity (loaded before each job)

Profiles Available:
  - slurm: Production HPC with container (default)
  - standard: Local execution without SLURM
  - test: Test mode with limited pairs (--test_mode true)

═══════════════════════════════════════════════════════════════════════════════

MONITORING AND DEBUGGING
═══════════════════════════════════════════════════════════════════════════════

Watch progress:
  nextflow run main.nf -profile slurm -with-timeline timeline.html \
                        -with-report report.html -with-trace trace.txt

Check logs:
  .nextflow/logs/  (overall execution logs)
  tail -f .nextflow.log  (live monitoring)

Check work directory:
  .nextflow/work/XX/YYYYYY/  (per-process directories)
  ls work/*/*/.command.{sh,log,err,out}  (inspect job files)

Check SLURM jobs:
  squeue -u $USER  (see running/pending jobs)
  sacct -j JOBID --format=JobID,JobName,State,ExitCode,MaxRSS,Elapsed

Inspect intermediate results:
  # Load R data files
  R console: load("work/XX/YYYYYY/01_filtered_data.RData")
  R console: head(ortho)
  R console: dim(species1_net)
  
  # Check process output
  cat work/XX/YYYYYY/.command.log
  cat work/XX/YYYYYY/.command.err

Final results location:
  rcomplex_data/{tissue}/results/{pair_id}/
    ├── 04_summary_statistics.tsv
    ├── 04_pvalue_correlation.png
    └── 04_effect_size_plot.png
  
  results/{tissue}/
    ├── cliques.qs2 (fast qs2 serialization)
    ├── cliques.csv (all cliques)
    ├── cliques_annual.csv
    ├── cliques_perennial.csv
    ├── cliques_shared.csv
    ├── cliques_unsigned.qs2 (when --run_unsigned)
    ├── cliques_unsigned.csv (when --run_unsigned)
    ├── cliques_unsigned_annual.csv (when --run_unsigned)
    ├── cliques_unsigned_perennial.csv (when --run_unsigned)
    ├── cliques_unsigned_shared.csv (when --run_unsigned)
    └── polarity/ (when --run_unsigned)
        └── polarity_divergence_{pair_id}.tsv

═══════════════════════════════════════════════════════════════════════════════

ERROR RECOVERY
═══════════════════════════════════════════════════════════════════════════════

Automatic Retry Mechanisms:
  - Steps 2 & 3 have automatic retry on OOM (exit 137)
  - Retry with increased resources (2x CPUs, 2x memory)
  - Max retries: 2 attempts per task

If Step 2 (COMPUTE_NETWORKS) fails:
  1. Check error in work directory:
     cat work/XX/YYYYYY/.command.err
  2. Common issues:
     - OOM (exit 137): Will auto-retry with more memory
     - Data corruption: Check 01_filtered_data.RData
     - Correlation computation failure: Check R package versions
  3. Resume pipeline:
     nextflow run main.nf -profile slurm -resume
  4. Nextflow will re-run failed tasks and cascade to 3, 4

If Step 3 (NETWORK_COMPARISON) fails:
  1. Check error message in work directory:
     cat work/XX/YYYYYY/.command.err
     cat work/XX/YYYYYY/.command.log
  2. Common issues:
     - OOM (exit 137): Will auto-retry with more memory
     - Missing orthologs: Check data consistency in step 1
     - Hypergeometric test failure: Check neighborhood sizes
  3. Manual re-run (if needed):
     apptainer exec RComPlEx.sif \
       Rscript scripts/rcomplex_03_network_comparison.R \
         --tissue root --pair_id Species1_Species2 \
         --workdir . --indir work/XX/YYYYYY --outdir . --cores 12
  4. Resume pipeline:
     nextflow run main.nf -profile slurm -resume

If FIND_CLIQUES_STREAMING fails:
  1. Check memory usage (starts at 64 GB, retries up to 256 GB)
  2. Verify all 03_comparison.RData files exist
  3. Check error logs: work/XX/YYYYYY/.command.err
  4. Common issues:
     - OOM (exit 137): Will auto-retry with 2× memory
     - Missing comparison files: Check RCOMPLEX_04 completed for all pairs
     - R serialization: Ensure qs2 package in container
  5. Resume with: nextflow run main.nf -profile slurm -resume

General Debugging Strategy:
  1. Find failed task work directory: .nextflow/work/XX/YYYYYY/
  2. Check SLURM logs: .command.log, .command.err
  3. Inspect input data: load RData files in R console
  4. Check resource usage: sacct -j JOBID --format=MaxRSS,Elapsed
  5. Fix issue and resume: nextflow run main.nf -resume
  6. Always use -resume to avoid re-running successful tasks

═══════════════════════════════════════════════════════════════════════════════
