# Annual Clique Network Overlap Analysis - Implementation Plan

## Overview

**IMPORTANT**: This is a **downstream, post-hoc analysis** that runs **AFTER** the main RComPlEx Nextflow pipeline completes.

Create a standalone analysis tool to compare co-expression networks between annual-only cliques (generated by the RComPlEx pipeline) and their orthologous genes in perennial congener species. This will help investigate whether annuality results from gene loss or differential co-expression patterns.

**Workflow Position**:
```
Main RComPlEx Pipeline (Nextflow)
├── PREPARE_PAIR
├── RCOMPLEX_01_LOAD_FILTER
├── RCOMPLEX_02_COMPUTE_NETWORKS
├── RCOMPLEX_03_NETWORK_COMPARISON
├── RCOMPLEX_04_SUMMARY_STATS
└── FIND_CLIQUES  ← Generates annual_cliques.tsv
    ↓
    [Pipeline Complete]
    ↓
╔═══════════════════════════════════════════════════════════╗
║  POST-HOC ANALYSIS (This Plan - Run Separately)          ║
╠═══════════════════════════════════════════════════════════╣
║  analyze_clique_networks.R                                ║
║  ├── Load annual cliques from pipeline output             ║
║  ├── Recompute networks for congener pairs only           ║
║  ├── Compare annual vs perennial neighborhoods            ║
║  └── Generate overlap statistics and Cytoscape files      ║
╚═══════════════════════════════════════════════════════════╝
```

## User Requirements

1. **Find annual-exclusive cliques** (already part of main pipeline)
2. **Compare gene neighborhoods** for genes in annual cliques vs their **congener perennial orthologs**:
   - Brachypodium distachyon (annual) ↔ Brachypodium sylvaticum (perennial)
   - Poa annua (annual) ↔ Poa supina (perennial)
   - Briza maxima (annual) ↔ Briza media (perennial)
   - Vulpia bromoides (annual) ↔ Festuca pratensis (perennial)
   - Hordeum vulgare (annual) ↔ Hordeum jubatum (perennial)
3. **Analyze both node and edge level**:
   - Node: Does the gene have co-expression partners in one species but not the other?
   - Edge: Which specific gene-gene connections are species-specific vs shared?
   - Partners: Are the co-expression partners orthologous or completely different genes?
4. **Metrics**: Jaccard similarity, overlap coefficients, edge conservation, partner orthology
5. **Scope**: ALL annual-only cliques, compared to their taxonomic congeners
6. **Outputs**:
   - Summary statistics table (per-clique, per-congener-pair metrics)
   - Edge-level comparison (conserved, annual-specific, perennial-specific edges)
   - Network files in Cytoscape-compatible format with edge categories
   - Gene lists with functional context

## Architecture Decision: Standalone R Script (NOT part of Nextflow pipeline)

**Approach**: Create a standalone R script that runs **separately AFTER** the main Nextflow pipeline completes. This is a completely independent post-hoc analysis, not integrated into the Nextflow workflow.

**Rationale**:
- **Separation of concerns**: Main pipeline focuses on all-vs-all species comparisons; this focuses only on specific congener pairs
- **Efficiency**: Networks are large (~30k × 30k) and not currently saved by main pipeline - storing all would require TBs
- **Flexibility**: Recomputing selectively for congener pairs only is more efficient than saving everything
- **Iteration**: Standalone script allows parameter tuning without re-running the expensive main pipeline
- **Future option**: Can add Nextflow wrapper later if this analysis becomes routine, but for now it's a one-off exploration

**Execution Model**:
1. User runs main RComPlEx pipeline → generates cliques
2. Pipeline completes and FIND_CLIQUES outputs `coexpressolog_cliques_*_annual.tsv`
3. User manually runs `analyze_clique_networks.R` as a separate SLURM job
4. This script loads clique files, recomputes networks for congener pairs, and outputs results

## Implementation Strategy

### High-Level Workflow

```
1. Load annual cliques → identify required species pairs
2. For each unique species pair needed:
   - Load filtered expression data (reuse existing files)
   - Recompute correlation + normalization (reuse existing code)
   - Extract neighborhoods for clique genes only
3. For each annual clique:
   - Compare annual neighborhoods vs perennial neighborhoods
   - Calculate overlap metrics
   - Identify differential partners
4. Output statistics tables and Cytoscape network files
```

## Files to Create

### 1. `scripts/analyze_clique_networks.R` (Main Script)

**Purpose**: Orchestrate the complete analysis workflow

**Key sections**:
- Load configuration and clique files
- Identify required species pairs (deduplicate across cliques)
- Compute/cache networks with intelligent memory management
- Analyze each clique (compare annual vs perennial neighborhoods)
- Write outputs (tables, gene lists, Cytoscape files)

**Command-line interface**:
```r
Rscript scripts/analyze_clique_networks.R \
  --tissue root \
  --cliques results/root/coexpressolog_cliques_root_annual.tsv \
  --data_dir rcomplex_data \
  --config config/pipeline_config.yaml \
  --outdir results/clique_network_analysis \
  --cores 8
```

### 2. `scripts/lib/network_utils.R` (Network Computation)

**Purpose**: Extract and reuse correlation/normalization code from existing pipeline

**Key functions**:
- `compute_network_neighborhoods()`: Main function to recompute networks for specific genes
  - Load `01_filtered_data.RData` from published pair directory
  - Compute Spearman correlation (parallel, reuse existing code)
  - Apply MR normalization and density threshold
  - Extract neighborhoods only for genes of interest (sparse storage)
  - Return: gene → list of neighbors (not full matrix)

- `extract_neighborhoods()`: Extract neighbors above threshold for specific genes
- `apply_mr_normalization()`: Mutual rank normalization (from rcomplex_02)
- `compute_correlation_matrix()`: Parallel correlation computation (from rcomplex_02)

**Code to extract from**: `scripts/rcomplex_02_compute_networks.R` lines 148-252

### 3. `scripts/lib/neighborhood_comparison.R` (Overlap Analysis)

**Purpose**: Compare neighborhoods and calculate metrics

**Key functions**:
- `analyze_single_clique()`: Process one clique across all valid perennial species
- `compare_neighborhoods()`: Compare annual vs perennial neighborhoods gene-by-gene
  - Map annual neighborhood to perennial ortholog space
  - Extract actual perennial neighborhood
  - Calculate Jaccard similarity: |A ∩ P| / |A ∪ P|
  - Calculate overlap coefficient: |A ∩ P| / min(|A|, |P|)
  - Identify: shared, annual-specific, perennial-specific partners

- `map_ortholog()`: Map gene from one species to another using ortholog table
- `map_gene_set()`: Map entire neighborhood through ortholog table
- `filter_perennials_with_full_coverage()`: Check if perennial has ALL clique orthologs

## Output Structure

```
results/clique_network_analysis/
├── clique_overlap_statistics.tsv           # Main summary table
│   Columns: CliqueID, CliqueSizeGenes, AnnualSpecies, CongenerPerennial,
│            GenesConnectedBoth, GenesAnnualOnly, GenesPerennialOnly, GenesIsolatedBoth,
│            MeanEdgeConservationRate, MedianEdgeConservationRate,
│            MeanJaccard, MedianJaccard, MeanOverlapCoef,
│            TotalConservedEdges, TotalAnnualSpecificEdges, TotalPerennialSpecificEdges
│
├── clique_details/
│   └── clique_{ID}_{annual}_{perennial}_gene_metrics.tsv  # Per-gene metrics
│       Columns: CliqueID, AnnualGene, PerennialOrtholog, CongenerPair,
│                ConnectivityStatus (connected_both/annual_only/perennial_only/isolated_both),
│                AnnualNeighborhoodSize, PerennialNeighborhoodSize,
│                NumConservedEdges, NumAnnualSpecificEdges, NumPerennialSpecificEdges,
│                EdgeConservationRate, EdgeGainRate,
│                Jaccard, OverlapCoefficient,
│                AnnualPartnersWithOrthologs_Pct, PerennialPartnersWithOrthologs_Pct
│
├── edge_classifications/
│   ├── clique_{ID}_{annual}_{perennial}_conserved_edges.tsv
│   │   Columns: CliqueGene_Annual, CliqueGene_Perennial,
│   │            PartnerGene_Annual, PartnerGene_Perennial,
│   │            AnnualEdgeWeight, PerennialEdgeWeight, WeightDifference
│   │
│   ├── clique_{ID}_{annual}_{perennial}_annual_specific_edges.tsv
│   │   Columns: CliqueGene_Annual, PartnerGene_Annual, EdgeWeight,
│   │            PartnerPerennialOrtholog (or "NO_ORTHOLOG"),
│   │            ReasonForLoss (no_ortholog/not_expressed/not_coexpressed)
│   │
│   └── clique_{ID}_{annual}_{perennial}_perennial_specific_edges.tsv
│       Columns: CliqueGene_Perennial, PartnerGene_Perennial, EdgeWeight,
│                PartnerAnnualOrtholog (or "NO_ORTHOLOG"),
│                ReasonForGain (no_ortholog/annual_not_expressed/divergent_expression)
│
├── partner_gene_lists/
│   ├── clique_{ID}_{annual}_{perennial}_shared_partners.txt
│   ├── clique_{ID}_{annual}_{perennial}_annual_specific_partners.txt
│   └── clique_{ID}_{annual}_{perennial}_perennial_specific_partners.txt
│
└── cytoscape_networks/
    ├── clique_{ID}_{annual}_vs_{perennial}_combined.tsv  # Single network with both
    ├── clique_{ID}_{annual}_network.tsv                  # Annual only
    ├── clique_{ID}_{perennial}_network.tsv               # Perennial only
    └── clique_{ID}_node_and_edge_attributes.tsv          # Attributes for both
        Node attributes: gene, species, node_type (clique/neighbor),
                        connectivity_status, neighborhood_size
        Edge attributes: source, target, interaction, edge_category
                        (conserved/annual_specific/perennial_specific),
                        annual_weight, perennial_weight
```

### Cytoscape File Format Details

**Edge files** (`*_network.tsv`):
- Tab-separated with header: `source	target	interaction	weight`
- One row per edge (undirected: only include A-B, not B-A)
- Weight = correlation strength after normalization
- Include edges for clique genes AND their neighborhood

**Node attributes** (`*_node_attributes.tsv`):
- Tab-separated with header: `gene	node_type	species	in_clique	neighborhood_overlap`
- `node_type`: "clique_member" or "neighbor"
- `in_clique`: TRUE/FALSE
- `neighborhood_overlap`: "annual_specific", "perennial_specific", "shared", or "N/A"

**Import instructions for user**:
1. Open Cytoscape
2. File → Import → Network from File → select `*_network.tsv`
3. File → Import → Table from File → select `*_node_attributes.tsv`
4. Map attributes to nodes by "gene" column
5. Apply layout (e.g., Prefuse Force Directed)
6. Style nodes by `node_type` and `neighborhood_overlap`

## Algorithm: Core Logic

### Step 1: Parse Cliques and Identify Required Congener Pairs

```
# Define congener pairs (taxonomically related annual-perennial)
CONGENER_PAIRS = [
  ("Brachypodium_distachyon", "Brachypodium_sylvaticum"),
  ("Poa_annua", "Poa_supina"),
  ("Briza_maxima", "Briza_media"),
  ("Vulpia_bromoides", "Festuca_pratensis"),
  ("Hordeum_vulgare", "Hordeum_jubatum")
]

For each annual-only clique:
  1. Parse Genes column (comma-separated) and Species column (semicolon-separated)
  2. Create gene-to-species mapping
  3. Identify which annual species are present in the clique
  4. For each annual species in clique:
     - Find its congener perennial from CONGENER_PAIRS
     - Check if perennial has orthologs for the clique genes from this annual
     - If yes: add (annual, perennial) pair to required list
  5. Store mapping: clique_id → list of (annual_sp, perennial_sp, annual_genes, perennial_orthologs)

Note: Only need to compute networks for the specific congener pairs, not all perennials
This is much more efficient than checking all perennial species
```

### Step 2: Compute Networks with Intelligent Caching

```
network_cache = empty hash map

For each unique (species1, species2) pair:
  1. Load published filtered data:
     rcomplex_data/{tissue}/pairs/{sp1}_{sp2}/01_filtered_data.RData

  2. Extract: species1_expr, species2_expr, ortho table

  3. Compute correlation matrices:
     - Transpose expression matrices
     - Parallel Spearman correlation using furrr
     - Apply MR normalization (row-wise ranking in parallel)
     - Calculate density threshold (top 3%)

  4. For genes of interest in this pair (across all cliques needing this pair):
     - Extract neighborhood: all genes above threshold
     - Store as sparse list: gene_id → c(neighbor1, neighbor2, ...)

  5. Cache result:
     network_cache[(sp1, sp2)] = list(
       species1 = list(name = sp1, neighborhoods = ...),
       species2 = list(name = sp2, neighborhoods = ...),
       ortho = ortho_table
     )

  6. Memory management:
     - If cache size > 4 pairs, write oldest to disk and release
     - Track which cliques need which pairs to optimize processing order
```

### Step 3: Analyze Each Clique - Node and Edge Level

```
For each annual clique:
  1. Identify congener perennial for each annual species in clique (from CONGENER_PAIRS)

  2. For each annual species in clique:
     For each clique gene in that species:

       a) Get annual neighborhood from cache:
          - Retrieve from network_cache[(annual_sp, congener_perennial_sp)]
          - Neighborhood = list of co-expressed genes above threshold
          - Also extract edge weights (correlation values)

       b) Map clique gene to perennial ortholog:
          - Use ortho table from the annual-perennial pair
          - Handle missing orthologs (log and skip this gene)
          - Handle multiple orthologs (analyze each)

       c) Get perennial neighborhood for the ortholog:
          - Retrieve from same network_cache entry
          - Extract co-expressed partners above threshold
          - Extract edge weights

       d) NODE-LEVEL ANALYSIS:
          - Is gene connected (has neighbors) in annual? Yes/No
          - Is ortholog connected in perennial? Yes/No
          - Neighborhood size in annual vs perennial
          - Categorize: "connected_in_both", "annual_only", "perennial_only", "isolated_in_both"

       e) EDGE-LEVEL ANALYSIS:
          i) Map annual neighborhood to perennial ortholog space:
             - For each annual neighbor gene, find its perennial ortholog
             - Create set of mapped perennial genes (expected partners)

          ii) Compare edges:
              - Conserved edges: annual neighbor has perennial ortholog that IS in perennial neighborhood
              - Annual-specific edges: annual neighbor has perennial ortholog that is NOT in perennial neighborhood
              - Perennial-specific edges: perennial has partners whose orthologs are NOT in annual neighborhood

          iii) Partner orthology analysis:
               - What % of annual partners have orthologs in perennial species?
               - What % of perennial partners have orthologs in annual species?
               - Are non-conserved edges due to gene loss or expression divergence?

       f) Calculate metrics:
          - Jaccard similarity: |conserved_edges| / |union_of_edges|
          - Overlap coefficient: |conserved_edges| / min(|annual_edges|, |perennial_edges|)
          - Edge conservation rate: |conserved_edges| / |annual_edges|
          - Edge gain rate: |perennial_specific_edges| / |perennial_edges|

       g) Store detailed results:
          - Per-gene summary (connectivity status, metrics)
          - Per-edge classification (conserved, annual-specific, perennial-specific)
          - Partner gene lists with orthology information
```

### Step 4: Generate Outputs

**Statistics Table**:
- Aggregate per-gene metrics to clique level (mean, median, stdev)
- One row per clique-annual_sp-perennial_sp combination

**Gene Lists**:
- Flatten shared/differential partner lists
- Include metadata: which gene, which partner, in which species

**Cytoscape Networks**:
- Extract subgraph: clique genes + their neighborhoods
- Create edge list with weights
- Create node attribute table with categories
- One network file per clique per species comparison

## Key Implementation Details

### Handling Missing Orthologs

```r
# When mapping neighborhoods, track missing orthologs
map_gene_set <- function(genes, from_species, to_species, ortho_table) {
  mapped <- c()
  missing <- c()

  for (gene in genes) {
    orthologs <- ortho_table %>%
      filter(Species1 == gene & Species2_name == to_species) %>%
      pull(Species2)

    if (length(orthologs) > 0) {
      mapped <- c(mapped, orthologs)
    } else {
      missing <- c(missing, gene)
    }
  }

  return(list(mapped = unique(mapped), missing = missing))
}

# Report in output: "X% of neighbors could be mapped"
```

### Memory Management Strategy

```r
# Process cliques in batches by species pairs needed
# Example: Process all cliques needing pair (sp1, sp2) before moving on

cliques_by_pairs <- group_cliques_by_species_pairs(annual_cliques)

for (pair in unique_pairs) {
  # Load/compute network for this pair
  net <- compute_network_neighborhoods(pair, ...)

  # Process all cliques needing this pair
  for (clique in cliques_by_pairs[[pair]]) {
    analyze_single_clique(clique, net, ...)
  }

  # Release network from memory
  rm(net)
  gc()
}
```

### Cytoscape Network Export

```r
export_cytoscape_network <- function(clique_id, species, neighborhood_data,
                                      annual_specific, perennial_specific, shared) {

  # Create edge list
  edges <- tibble(
    source = character(),
    target = character(),
    interaction = "co-expression",
    weight = numeric()
  )

  # Add edges from network (undirected: only A-B, not B-A)
  for (gene in names(neighborhood_data)) {
    neighbors <- neighborhood_data[[gene]]
    for (neighbor in neighbors) {
      if (gene < neighbor) {  # Ensure undirected uniqueness
        edges <- edges %>% add_row(
          source = gene,
          target = neighbor,
          weight = get_correlation_weight(gene, neighbor, ...)
        )
      }
    }
  }

  # Create node attributes
  nodes <- tibble(
    gene = unique(c(edges$source, edges$target)),
    node_type = ifelse(gene %in% clique_genes, "clique_member", "neighbor"),
    species = species,
    in_clique = gene %in% clique_genes,
    neighborhood_overlap = case_when(
      gene %in% shared ~ "shared",
      gene %in% annual_specific ~ "annual_specific",
      gene %in% perennial_specific ~ "perennial_specific",
      TRUE ~ "N/A"
    )
  )

  # Write files
  write_tsv(edges, file.path(outdir, glue("clique_{clique_id}_{species}_network.tsv")))
  write_tsv(nodes, file.path(outdir, glue("clique_{clique_id}_{species}_nodes.tsv")))
}
```

## Resource Requirements

### Compute Resources:
- **CPUs**: 8-12 cores (for parallel correlation computation)
- **Memory**: 32-64 GB (to hold 3-4 species pair networks in memory)
- **Time**: 3-6 hours for ~50 cliques, ~30 species pairs
- **Storage**: <5 GB output (tables + network files)

### SLURM Submission Script:

Create `scripts/submit_clique_analysis.sh`:
```bash
#!/bin/bash
#SBATCH --job-name=clique_network_analysis
#SBATCH --partition=orion
#SBATCH --qos=normal
#SBATCH --time=08:00:00
#SBATCH --mem=64G
#SBATCH --cpus-per-task=12
#SBATCH --output=logs/clique_analysis_%j.log
#SBATCH --error=logs/clique_analysis_%j.err

# Load modules
module load singularity

# Run analysis in container
apptainer exec RComPlEx.sif Rscript scripts/analyze_clique_networks.R \
  --tissue root \
  --cliques results/root/coexpressolog_cliques_root_annual.tsv \
  --data_dir rcomplex_data \
  --config config/pipeline_config.yaml \
  --outdir results/clique_network_analysis \
  --cores 12

echo "Analysis complete!"
```

## Critical Files Referenced

### To Extract Code From:
- `scripts/rcomplex_02_compute_networks.R` (lines 148-252)
  - Correlation computation with parallel processing
  - MR normalization algorithm
  - Threshold calculation logic

### To Read Structure From:
- `scripts/find_coexpressolog_cliques.R` (lines 130-168)
  - How clique structure is stored (Genes column format)
  - How species information is encoded

### To Load Config From:
- `config/pipeline_config.yaml`
  - Network parameters: cor_method, norm_method, density_thr
  - Must reuse exact same parameters for consistency

### To Load Data From:
- `rcomplex_data/{tissue}/pairs/{sp1}_{sp2}/01_filtered_data.RData`
  - Contains: species1_expr, species2_expr, ortho table
  - Already exists from main pipeline (no recomputation needed)

## Validation Strategy

### Sanity Checks During Execution:
1. Report number of perennial species with full ortholog coverage per clique
2. Log cliques where no valid perennials exist
3. Report % of neighborhood genes that could be mapped through orthologs
4. Check that neighborhood sizes are reasonable (compare to existing stats)

### Quality Metrics to Include in Output:
- Ortholog mapping success rate per clique
- Distribution of Jaccard similarities (expect bimodal: conserved vs divergent)
- Median neighborhood sizes (annual vs perennial)
- Number of differential partners (annual-specific vs perennial-specific)

### Manual Validation Steps:
1. Spot-check 2-3 cliques by manually inspecting networks
2. Verify Cytoscape files import correctly
3. Compare overlap statistics to biological expectations
4. Check for systematic biases (e.g., one species always has larger neighborhoods)

## Execution Instructions

### IMPORTANT: This is a Separate Post-Hoc Analysis

**DO NOT** run this during the main Nextflow pipeline. This analysis runs **AFTER** the main RComPlEx pipeline completes.

### Step-by-Step Workflow:

#### Phase 1: Wait for Main Pipeline to Complete

1. **Monitor main pipeline**:
   ```bash
   tail -f nf-complex_*.out
   # Wait until you see "FIND_CLIQUES" complete
   ```

2. **Verify pipeline completion**:
   ```bash
   # Check for clique output files
   ls results/root/coexpressolog_cliques_root_annual.tsv
   ls results/leaf/coexpressolog_cliques_leaf_annual.tsv

   # Verify filtered data exists for all pairs
   ls rcomplex_data/root/pairs/*/01_filtered_data.RData | wc -l
   # Should show ~156 files (all species pairs)
   ```

#### Phase 2: Run Post-Hoc Congener Analysis

3. **Create log directory**:
   ```bash
   mkdir -p logs
   ```

4. **Submit congener analysis job** (SEPARATE from main pipeline):
   ```bash
   sbatch scripts/submit_clique_analysis.sh
   ```

4. **Monitor progress**:
   ```bash
   tail -f logs/clique_analysis_*.log
   ```

5. **Check outputs**:
   ```bash
   ls results/clique_network_analysis/
   head results/clique_network_analysis/clique_overlap_statistics.tsv
   ```

6. **Import to Cytoscape**:
   - Open Cytoscape
   - Import network file (`.tsv` from `cytoscape_networks/`)
   - Import node attributes
   - Apply visual style to highlight differential partners

## Future Extensions (Optional)

1. **Permutation testing**: Test if overlap is significant vs random
2. **Functional enrichment**: GO/KEGG enrichment of differential partners
3. **Evolutionary analysis**: Correlate overlap with phylogenetic distance
4. **Automated visualization**: Generate Cytoscape session files programmatically
5. **Batch mode**: Process multiple tissues in one run

## Implementation Timeline

- **Day 1-2**: Extract and refactor network computation code into `lib/network_utils.R`
- **Day 3-4**: Implement comparison logic in `lib/neighborhood_comparison.R`
- **Day 5-6**: Write main analysis script with I/O and orchestration
- **Day 7**: Test on subset of cliques, debug edge cases
- **Day 8**: Run full analysis, validate outputs, document usage

---

## Code Templates for Implementation

### Template 1: `scripts/lib/network_utils.R`

```r
#!/usr/bin/env Rscript
# ==============================================================================
# Network Utilities for Clique Analysis
# ==============================================================================
# Functions to recompute co-expression networks for specific gene sets
# Extracted from rcomplex_02_compute_networks.R for reuse
# ==============================================================================

suppressPackageStartupMessages({
  library(tidyverse)
  library(furrr)
  library(future)
})

#' Compute neighborhoods for specific genes in a species pair
#'
#' @param tissue Tissue being analyzed (root/leaf)
#' @param species1 First species name
#' @param species2 Second species name
#' @param genes_of_interest Named list: list(sp1 = c(genes...), sp2 = c(genes...))
#' @param config Pipeline configuration from config_parser
#' @param data_dir Base directory with filtered data (e.g., "rcomplex_data")
#' @param n_cores Number of cores for parallel processing
#' @return List with neighborhoods and ortho table
compute_network_neighborhoods <- function(tissue, species1, species2,
                                          genes_of_interest,
                                          config, data_dir, n_cores = 8) {

  cat("Computing networks for:", species1, "vs", species2, "\n")

  # Load filtered data from step 1
  pair_dir <- file.path(data_dir, tissue, "pairs",
                        paste0(species1, "_", species2))
  input_file <- file.path(pair_dir, "01_filtered_data.RData")

  if (!file.exists(input_file)) {
    stop("Filtered data not found: ", input_file)
  }

  load(input_file)  # Loads: species1_expr, species2_expr, ortho, species1_name, species2_name

  # Extract parameters
  cor_method <- config$rcomplex$cor_method
  norm_method <- config$rcomplex$norm_method
  density_thr <- config$rcomplex$density_thr

  # Setup parallel
  plan(multisession, workers = min(2, n_cores))
  options(future.globals.maxSize = Inf)

  # Compute correlation matrices (parallel across species)
  cat("  Computing correlation matrices...\n")
  correlation_results <- future_map(
    list(
      list(expr = species1_expr, name = species1_name),
      list(expr = species2_expr, name = species2_name)
    ),
    function(sp) {
      expr_matrix <- t(sp$expr[, -1])
      net <- cor(expr_matrix, method = cor_method)
      dimnames(net) <- list(sp$expr$Genes, sp$expr$Genes)
      return(net)
    },
    .options = furrr_options(seed = TRUE)
  )

  species1_net <- correlation_results[[1]]
  species2_net <- correlation_results[[2]]
  rm(correlation_results)
  gc(verbose = FALSE)

  # Apply MR normalization
  if (norm_method == "MR") {
    cat("  Applying MR normalization...\n")
    plan(multisession, workers = n_cores)

    # Species 1
    R1_list <- future_map(1:nrow(species1_net), function(i) {
      rank(species1_net[i, ])
    }, .options = furrr_options(seed = TRUE))
    R1 <- do.call(rbind, R1_list)
    species1_net <- sqrt(R1 * t(R1))
    rm(R1, R1_list)
    gc(verbose = FALSE)

    # Species 2
    R2_list <- future_map(1:nrow(species2_net), function(i) {
      rank(species2_net[i, ])
    }, .options = furrr_options(seed = TRUE))
    R2 <- do.call(rbind, R2_list)
    species2_net <- sqrt(R2 * t(R2))
    rm(R2, R2_list)
    gc(verbose = FALSE)
  }

  # Remove diagonals
  diag(species1_net) <- 0
  diag(species2_net) <- 0

  # Compute thresholds
  cat("  Computing density thresholds...\n")
  R <- sort(species1_net[upper.tri(species1_net, diag = FALSE)], decreasing = TRUE)
  species1_thr <- R[round(density_thr * length(R))]

  R <- sort(species2_net[upper.tri(species2_net, diag = FALSE)], decreasing = TRUE)
  species2_thr <- R[round(density_thr * length(R))]

  rm(R)
  gc(verbose = FALSE)

  # Extract neighborhoods only for genes of interest
  cat("  Extracting neighborhoods for genes of interest...\n")

  extract_neighborhoods_for_genes <- function(net, gene_list, threshold) {
    result <- list()
    for (gene in gene_list) {
      if (gene %in% rownames(net)) {
        neighbors <- net[gene, ]
        result[[gene]] <- list(
          neighbors = names(neighbors[neighbors >= threshold]),
          weights = neighbors[neighbors >= threshold]
        )
      }
    }
    return(result)
  }

  species1_neighborhoods <- extract_neighborhoods_for_genes(
    species1_net, genes_of_interest$sp1, species1_thr
  )

  species2_neighborhoods <- extract_neighborhoods_for_genes(
    species2_net, genes_of_interest$sp2, species2_thr
  )

  cat("  ✓ Network computation complete\n\n")

  return(list(
    species1 = list(
      name = species1_name,
      neighborhoods = species1_neighborhoods,
      threshold = species1_thr
    ),
    species2 = list(
      name = species2_name,
      neighborhoods = species2_neighborhoods,
      threshold = species2_thr
    ),
    ortho = ortho
  ))
}
```

### Template 2: `scripts/lib/neighborhood_comparison.R`

```r
#!/usr/bin/env Rscript
# ==============================================================================
# Neighborhood Comparison Utilities
# ==============================================================================
# Functions to compare gene neighborhoods between annual and perennial species
# ==============================================================================

suppressPackageStartupMessages({
  library(tidyverse)
})

#' Compare neighborhoods for a single gene between annual and perennial
#'
#' @param annual_gene Gene ID in annual species
#' @param perennial_ortholog Gene ID in perennial species
#' @param annual_neighborhood List with neighbors and weights
#' @param perennial_neighborhood List with neighbors and weights
#' @param ortho_table Ortholog mapping table
#' @param annual_species Annual species name
#' @param perennial_species Perennial species name
#' @return Tibble with comparison metrics and classifications
compare_gene_neighborhoods <- function(annual_gene, perennial_ortholog,
                                        annual_neighborhood,
                                        perennial_neighborhood,
                                        ortho_table,
                                        annual_species, perennial_species) {

  # Extract neighbor lists
  annual_neighbors <- annual_neighborhood$neighbors
  perennial_neighbors <- perennial_neighborhood$neighbors

  # Node-level metrics
  annual_connected <- length(annual_neighbors) > 0
  perennial_connected <- length(perennial_neighbors) > 0

  connectivity_status <- case_when(
    annual_connected & perennial_connected ~ "connected_both",
    annual_connected & !perennial_connected ~ "annual_only",
    !annual_connected & perennial_connected ~ "perennial_only",
    TRUE ~ "isolated_both"
  )

  # Edge-level analysis: Map annual neighbors to perennial space
  annual_mapped <- map_gene_set(annual_neighbors, ortho_table,
                                 from_species = annual_species,
                                 to_species = perennial_species)

  perennial_mapped <- map_gene_set(perennial_neighbors, ortho_table,
                                   from_species = perennial_species,
                                   to_species = annual_species)

  # Identify edge categories
  conserved_edges <- intersect(annual_mapped$mapped, perennial_neighbors)
  annual_specific_edges <- setdiff(annual_mapped$mapped, perennial_neighbors)
  perennial_specific_edges <- setdiff(perennial_neighbors, perennial_mapped$reverse_mapped)

  n_conserved <- length(conserved_edges)
  n_annual_specific <- length(annual_specific_edges)
  n_perennial_specific <- length(perennial_specific_edges)

  # Metrics
  n_annual_edges <- length(annual_neighbors)
  n_perennial_edges <- length(perennial_neighbors)

  edge_conservation_rate <- if (n_annual_edges > 0) {
    n_conserved / n_annual_edges
  } else { NA }

  edge_gain_rate <- if (n_perennial_edges > 0) {
    n_perennial_specific / n_perennial_edges
  } else { NA }

  union_size <- length(union(annual_mapped$mapped, perennial_neighbors))
  jaccard <- if (union_size > 0) {
    n_conserved / union_size
  } else { NA }

  overlap_coef <- if (min(n_annual_edges, n_perennial_edges) > 0) {
    n_conserved / min(n_annual_edges, n_perennial_edges)
  } else { NA }

  # Partner orthology rates
  pct_annual_partners_with_ortho <- if (n_annual_edges > 0) {
    length(annual_mapped$mapped) / n_annual_edges * 100
  } else { NA }

  pct_perennial_partners_with_ortho <- if (n_perennial_edges > 0) {
    length(perennial_mapped$mapped) / n_perennial_edges * 100
  } else { NA }

  # Return summary
  tibble(
    AnnualGene = annual_gene,
    PerennialOrtholog = perennial_ortholog,
    ConnectivityStatus = connectivity_status,
    AnnualNeighborhoodSize = n_annual_edges,
    PerennialNeighborhoodSize = n_perennial_edges,
    NumConservedEdges = n_conserved,
    NumAnnualSpecificEdges = n_annual_specific,
    NumPerennialSpecificEdges = n_perennial_specific,
    EdgeConservationRate = edge_conservation_rate,
    EdgeGainRate = edge_gain_rate,
    Jaccard = jaccard,
    OverlapCoefficient = overlap_coef,
    AnnualPartnersWithOrthologs_Pct = pct_annual_partners_with_ortho,
    PerennialPartnersWithOrthologs_Pct = pct_perennial_partners_with_ortho
  )
}

#' Map a set of genes to their orthologs
#'
#' @param genes Vector of gene IDs
#' @param ortho_table Ortholog mapping table
#' @param from_species Source species name
#' @param to_species Target species name
#' @return List with mapped genes and missing genes
map_gene_set <- function(genes, ortho_table, from_species, to_species) {

  mapped <- c()
  missing <- c()

  for (gene in genes) {
    # Try both directions in ortho table
    orthologs <- ortho_table %>%
      filter((Species1 == gene) | (Species2 == gene)) %>%
      {
        if (nrow(.) > 0) {
          if (.$Species1[1] == gene) pull(., Species2) else pull(., Species1)
        } else {
          character(0)
        }
      }

    if (length(orthologs) > 0) {
      mapped <- c(mapped, orthologs)
    } else {
      missing <- c(missing, gene)
    }
  }

  return(list(
    mapped = unique(mapped),
    missing = missing
  ))
}

#' Analyze a single clique across congener pairs
#'
#' @param clique_row Row from cliques_annotated tibble
#' @param network_cache Hash map with precomputed networks
#' @param congener_pairs List of annual-perennial congener pairs
#' @param n1_data N1_clean gene annotations
#' @return List with summary stats and detailed edge classifications
analyze_single_clique <- function(clique_row, network_cache,
                                   congener_pairs, n1_data) {

  clique_id <- clique_row$CliqueID
  clique_genes <- str_split(clique_row$Genes, ",")[[1]]

  cat("Analyzing clique:", clique_id, "(", length(clique_genes), "genes )\n")

  # Map genes to species
  gene_species_map <- n1_data %>%
    filter(GeneID %in% clique_genes) %>%
    select(GeneID, species) %>%
    distinct()

  # Identify annual species in clique
  annual_species <- gene_species_map %>%
    filter(species %in% names(congener_pairs)) %>%
    pull(species) %>%
    unique()

  results <- list()

  for (annual_sp in annual_species) {
    perennial_sp <- congener_pairs[[annual_sp]]

    # Check if network exists for this pair
    pair_key <- paste(annual_sp, perennial_sp, sep = "_")
    if (!pair_key %in% names(network_cache)) {
      cat("  Skipping", annual_sp, "vs", perennial_sp, "(network not available)\n")
      next
    }

    net <- network_cache[[pair_key]]

    # Get genes for this annual species in the clique
    annual_genes <- gene_species_map %>%
      filter(species == annual_sp) %>%
      pull(GeneID)

    # Compare each gene
    for (gene in annual_genes) {
      # Map to perennial ortholog
      ortholog <- net$ortho %>%
        filter(Species1 == gene) %>%
        pull(Species2)

      if (length(ortholog) == 0) {
        cat("    No ortholog for", gene, "in", perennial_sp, "\n")
        next
      }

      # Get neighborhoods
      annual_neigh <- net$species1$neighborhoods[[gene]]
      perennial_neigh <- net$species2$neighborhoods[[ortholog[1]]]

      if (is.null(annual_neigh) || is.null(perennial_neigh)) {
        next
      }

      # Compare
      comparison <- compare_gene_neighborhoods(
        gene, ortholog[1],
        annual_neigh, perennial_neigh,
        net$ortho,
        annual_sp, perennial_sp
      )

      results[[paste(clique_id, annual_sp, perennial_sp, gene, sep = "_")]] <- comparison
    }
  }

  return(bind_rows(results))
}
```

### Template 3: Main Script Structure for `scripts/analyze_clique_networks.R`

```r
#!/usr/bin/env Rscript
# ==============================================================================
# Analyze Clique Network Overlap
# ==============================================================================
# Compare co-expression networks between annual-only cliques and their
# congener perennials
# ==============================================================================

suppressPackageStartupMessages({
  library(tidyverse)
  library(optparse)
  library(glue)
})

# Parse arguments
option_list <- list(
  make_option(c("-t", "--tissue"), type = "character", default = NULL,
              help = "Tissue to analyze", metavar = "character"),
  make_option(c("-c", "--cliques"), type = "character", default = NULL,
              help = "Path to annual cliques file", metavar = "character"),
  make_option(c("-d", "--data_dir"), type = "character", default = "rcomplex_data",
              help = "Directory with filtered data", metavar = "character"),
  make_option(c("--config"), type = "character", default = "config/pipeline_config.yaml",
              help = "Pipeline configuration file", metavar = "character"),
  make_option(c("-o", "--outdir"), type = "character", default = "results/clique_network_analysis",
              help = "Output directory", metavar = "character"),
  make_option(c("--cores"), type = "integer", default = 8,
              help = "Number of CPU cores", metavar = "integer")
)

opt_parser <- OptionParser(option_list = option_list)
opt <- parse_args(opt_parser)

# Validate arguments
if (is.null(opt$tissue) || is.null(opt$cliques)) {
  print_help(opt_parser)
  stop("--tissue and --cliques are required")
}

# Source utilities
source("R/config_parser.R")
source("scripts/lib/network_utils.R")
source("scripts/lib/neighborhood_comparison.R")

# Load config
config <- load_config(opt$config, workdir = ".")

# Define congener pairs
CONGENER_PAIRS <- list(
  "Brachypodium_distachyon" = "Brachypodium_sylvaticum",
  "Poa_annua" = "Poa_supina",
  "Briza_maxima" = "Briza_media",
  "Vulpia_bromoides" = "Festuca_pratensis",
  "Hordeum_vulgare" = "Hordeum_jubatum"
)

cat("\n")
cat(rep("=", 80), "\n", sep = "")
cat("Clique Network Overlap Analysis\n")
cat(rep("=", 80), "\n", sep = "")
cat("Tissue:", opt$tissue, "\n")
cat("Cliques file:", opt$cliques, "\n")
cat("Cores:", opt$cores, "\n")
cat(rep("=", 80), "\n\n")

# Load cliques
annual_cliques <- read_tsv(opt$cliques, show_col_types = FALSE)
cat("Loaded", nrow(annual_cliques), "annual cliques\n\n")

# Load N1 for gene annotations
n1 <- readRDS(config$data$n1_file) %>%
  mutate(species = str_replace(species, " ", "_"))

# STEP 1: Identify required species pairs
# ... implementation here ...

# STEP 2: Compute networks for required pairs
# ... implementation here ...

# STEP 3: Analyze each clique
# ... implementation here ...

# STEP 4: Generate outputs
# ... implementation here ...

cat("\n")
cat(rep("=", 80), "\n", sep = "")
cat("ANALYSIS COMPLETE\n")
cat(rep("=", 80), "\n")
```

---

## Summary

This plan provides an efficient post-pipeline analysis to compare co-expression networks between annual-exclusive cliques and their congener perennials. Key features:

1. **Congener-specific comparisons**: Focus on taxonomically paired species (Brachypodium-Brachypodium, Poa-Poa, etc.) rather than all perennials
2. **Multi-level analysis**:
   - Node level: Which genes are connected vs isolated in each species
   - Edge level: Which specific gene-gene co-expression relationships are conserved, lost, or gained
   - Partner level: Whether differential edges are due to gene loss or expression divergence
3. **Efficient computation**: Recompute networks on-demand only for genes/pairs needed, not all possible combinations
4. **Rich outputs**: Statistics tables, edge classifications, and Cytoscape networks for visualization

This will help investigate whether annual-exclusive cliques result from:
- Gene loss (partners missing in perennial)
- Differential co-expression (partners present but not co-expressed)
- Gain of new interactions in annuals
- Loss of ancestral interactions
