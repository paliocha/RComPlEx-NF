---
title: "Conservation and divergence of co-expression networks in R (RComPlEx-NG)"
author: "Torgeir Rhodén Hvidsten & Martin Paliocha"
date: '`r format(Sys.time(), "%d.%m.%Y")`'
output:
  html_document:
    theme: yeti
    code_folding: hide
    number_sections: false
editor_options:
  chunk_output_type: console
---

```{r libraries, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)
options(stringsAsFactors = FALSE)

library(tidyverse)
theme_set(theme_classic())
theme_update(plot.title = element_text(face="bold"))

library(gplots)
library(RColorBrewer)
library(DT)
library(cowplot)
library(matrixStats)

# Parallelization libraries
library(furrr)
library(future)
library(parallel)

cat("RComPlEx-NG: Next Generation with Parallelization\n")
cat("===================================================\n")
cat("Available CPU cores:", availableCores(), "\n")
cat("Using parallel processing with furrr and future\n\n")
```

### Set up species and input files

Using PLAZA ortholog groups from PlantGenIE inferred using OrthoMCL:
ftp://plantgenie.org/Data/Cross-Species/Orthologs/PLAZA/orthologs.ORTHO.plantgenie.txt.gz

Species names: from PLAZA e.g. "potri" and "piabi"

Expression files: tab-separated file where the first column contains gene names and is called "Genes". Here we use data from [AspWood](https://doi.org/10.1105/tpc.17.00153) and [NorWood](https://doi.org/10.1111/nph.14458).

```{r setup}
# Set defaults only if not already defined (e.g., from sourced config)
if (!exists("species1_name")) species1_name <- "potri"
if (!exists("species2_name")) species2_name <- "piabi"
if (!exists("species1_expr_file")) species1_expr_file <- "Data/AspWood_expression.txt"
if (!exists("species2_expr_file")) species2_expr_file <- "Data/NorWood_expression.txt"
if (!exists("ortholog_group_file")) ortholog_group_file <- "Data/orthologs.ORTHO.plantgenie.txt.gz"

# Parallelization settings
if (!exists("n_cores")) {
  n_cores <- availableCores() - 1  # Leave one core free
  if (n_cores < 1) n_cores <- 1
}
cat("Will use", n_cores, "CPU cores for parallel processing\n\n")

# Increase future.globals.maxSize to handle large network matrices
# Set to Inf - SLURM will enforce memory limits anyway
options(future.globals.maxSize = Inf)
```

### Read in ortholog groups and expression data

```{r input, warning=FALSE, error=FALSE, message=FALSE}

# Read in ortholog groups
# =======================

load(file = ortholog_group_file)

# Read in expression data
# =======================

species1_expr <- read.delim(species1_expr_file, sep = "\t", header = TRUE)

species2_expr <- read.delim(species2_expr_file, sep = "\t", header = TRUE)

# Filter orthologs based on expression data
# ==========================================
# Only keep ortholog pairs where BOTH genes are in the expression data

cat (length(unique(ortho$OrthoGroup)), " ortholog groups containing:\n",
     " ", length(unique(ortho$Species1)), " ", species1_name, " genes\n",
     " ", length(unique(ortho$Species2)), " ", species2_name, " genes\n\n",
     length(unique(species1_expr$Genes)), " expressed ", species1_name, " genes\n",
     length(unique(species2_expr$Genes)), " expressed ", species2_name, " genes\n",
     sep = "")

# Filter: keep only orthologs where BOTH species genes are in expression data
ortho_before_filter <- nrow(ortho)
ortho <- ortho %>%
  filter(Species1 %in% species1_expr$Genes & Species2 %in% species2_expr$Genes)

# Filter expression data to match orthologs
species1_expr <- species1_expr[species1_expr$Genes %in% ortho$Species1,]
species2_expr <- species2_expr[species2_expr$Genes %in% ortho$Species2,]

cat ("After filtering on expressed genes with ortholog:\n",
     " ", length(unique(ortho$OrthoGroup)), " ortholog groups containing: \n",
     "  ", length(unique(ortho$Species1)), " ", species1_name, " genes\n",
     "  ", length(unique(ortho$Species2)), " ", species2_name, " genes\n",
     "  (removed ", ortho_before_filter - nrow(ortho), " orthologs with missing genes)\n",
     sep = "")

```

### Compute co-expression networks

There are several parameters that need to be set:

- Correlation: Pearson, Spearman, ...
- Normalization: CLR or MR
- Network density threshold. This determines the co-expression threshold

```{r coexpression}
cor_method <- "spearman" # pearson spearman
cor_sign <- "" # abs
norm_method <- "MR" # CLR MR
density_thr <- 0.03
randomize <- "" # rand

cat ("Parameters", "\n",
     "  cor_method  = ", cor_method, "\n",
     "  norm_method = ", norm_method, "\n",
     "  density_thr = ", density_thr, "\n", sep = "")

comparison_RData <- paste0("RData/comparison-", species1_name, "-", species2_name, "-",
                           cor_sign, cor_method, norm_method, density_thr, randomize, ".RData")

if (!file.exists(comparison_RData)) {

  cat("\n=== COMPUTING CO-EXPRESSION NETWORKS ===\n")
  start_time <- Sys.time()

  if (randomize == "rand") {
    species1_expr$Genes <- sample(species1_expr$Genes, nrow(species1_expr), FALSE)
    species2_expr$Genes <- sample(species2_expr$Genes, nrow(species2_expr), FALSE)
  }

  # PARALLEL CORRELATION COMPUTATION
  # ================================
  cat("\nComputing correlation matrices in parallel...\n")
  cat("  Matrix size: ~", nrow(species1_expr), "×", nrow(species1_expr),
      " and ~", nrow(species2_expr), "×", nrow(species2_expr), "\n")

  # Set up parallel processing for correlation
  plan(multisession, workers = min(2, n_cores))  # 2 species in parallel

  cor_start <- Sys.time()

  # Parallel computation of both correlation matrices
  correlation_results <- future_map(
    list(
      list(expr = species1_expr, name = species1_name),
      list(expr = species2_expr, name = species2_name)
    ),
    function(sp) {
      expr_matrix <- t(sp$expr[,-1])
      net <- cor(expr_matrix, method = cor_method)
      dimnames(net) <- list(sp$expr$Genes, sp$expr$Genes)
      return(net)
    },
    .options = furrr_options(seed = TRUE)
  )

  species1_net <- correlation_results[[1]]
  species2_net <- correlation_results[[2]]

  # Clean up memory
  rm(correlation_results)
  gc(verbose = FALSE)

  cor_elapsed <- as.numeric(difftime(Sys.time(), cor_start, units = "secs"))
  cat("  ✓ Correlation computation completed in", round(cor_elapsed, 1), "seconds\n")

  if (cor_sign == "abs") {
    species1_net <- abs(species1_net)
    species2_net <- abs(species2_net)
  }

  # PARALLEL NORMALIZATION
  # ======================
  if (norm_method == "CLR") {
    cat("\nApplying CLR normalization...\n")
    norm_start <- Sys.time()

    z <- scale(species1_net)
    z[z < 0] <- 0
    species1_net <- sqrt(t(z)**2 + z**2)

    z <- scale(species2_net)
    z[z < 0] <- 0
    species2_net <- sqrt(t(z)**2 + z**2)

    norm_elapsed <- as.numeric(difftime(Sys.time(), norm_start, units = "secs"))
    cat("  ✓ CLR normalization completed in", round(norm_elapsed, 1), "seconds\n")

  } else if (norm_method == "MR") {
    cat("\nApplying Mutual Rank (MR) normalization in parallel...\n")
    cat("  Using", n_cores, "cores for row-wise ranking\n")
    norm_start <- Sys.time()

    # Set up parallel processing for MR normalization
    plan(multisession, workers = n_cores)

    # Parallel ranking for species 1
    cat("  - Ranking species 1 network rows...\n")
    R1_list <- future_map(1:nrow(species1_net), function(i) {
      rank(species1_net[i,])
    }, .options = furrr_options(seed = TRUE), .progress = TRUE)
    R1 <- do.call(rbind, R1_list)
    species1_net <- sqrt(R1 * t(R1))
    rm(R1, R1_list)
    gc(verbose = FALSE)

    # Parallel ranking for species 2
    cat("  - Ranking species 2 network rows...\n")
    R2_list <- future_map(1:nrow(species2_net), function(i) {
      rank(species2_net[i,])
    }, .options = furrr_options(seed = TRUE), .progress = TRUE)
    R2 <- do.call(rbind, R2_list)
    species2_net <- sqrt(R2 * t(R2))
    rm(R2, R2_list)
    gc(verbose = FALSE)

    norm_elapsed <- as.numeric(difftime(Sys.time(), norm_start, units = "secs"))
    cat("  ✓ MR normalization completed in", round(norm_elapsed, 1), "seconds\n")
  }

  diag(species1_net) <- 0
  diag(species2_net) <- 0

  # Compute thresholds
  cat("\nComputing network density thresholds...\n")
  R <- sort(species1_net[upper.tri(species1_net, diag = FALSE)], decreasing = TRUE)
  species1_thr <- R[round(density_thr*length(R))]
  plot(density(R), xlab = paste0(species1_name, " correlations"), main = "")

  R <- sort(species2_net[upper.tri(species2_net, diag = FALSE)], decreasing = TRUE)
  species2_thr <- R[round(density_thr*length(R))]
  plot(density(R), xlab = paste0(species2_name, " correlations"), main = "")

  rm(R)
  gc(verbose = FALSE)

  elapsed <- as.numeric(difftime(Sys.time(), start_time, units = "mins"))
  cat("\n✓ Co-expression network computation completed in", round(elapsed, 2), "minutes\n\n")

} else {
  cat("\nLoading pre-computed co-expression networks from:", comparison_RData, "\n")
  load(file = comparison_RData)
}

cat(species1_name, ": co-expr threshold = ", format(species1_thr, digits = 3) , "\n",
    species2_name, ": co-expr threshold = ", format(species2_thr, digits = 3) , "\n", sep = "")

```

### Network comparison

For each ortholog pair, p-values for for the overlap of network neighborhoods are computed in both direction.

```{r comparison, warning=FALSE, error=FALSE, message=FALSE}

if (!file.exists(comparison_RData)) {

  # Validate that all orthologs have genes in the networks
  # =====================================================
  # This prevents "subscript out of bounds" errors during parallel processing

  species1_net_genes <- rownames(species1_net)
  species2_net_genes <- rownames(species2_net)

  # Find orthologs with genes that exist in both networks
  valid_orthos <- ortho %>%
    filter(Species1 %in% species1_net_genes & Species2 %in% species2_net_genes)

  # If any orthologs were filtered out, update the ortho table
  if (nrow(valid_orthos) < nrow(ortho)) {
    filtered_count <- nrow(ortho) - nrow(valid_orthos)
    ortho <- valid_orthos
  }

  cat("\n=== PARALLEL NETWORK COMPARISON ===\n")
  cat("Processing", nrow(ortho), "ortholog pairs using", n_cores, "cores\n\n")

  comparison_start <- Sys.time()

  # Set up parallel processing for network comparison
  plan(multisession, workers = n_cores)

  # Pre-compute network dimensions for efficiency
  N1 <- nrow(species1_expr)
  N2 <- nrow(species2_expr)

  cat("Starting parallel network neighborhood comparison...\n")
  cat("(Progress bar will update as chunks complete)\n\n")

  # PARALLEL NETWORK COMPARISON LOOP
  # ================================
  comparison <- ortho %>%
    mutate(row_id = row_number()) %>%
    group_split(row_id) %>%
    future_map_dfr(function(row_data) {

      i <- row_data$row_id

      # Species 1 -> Species 2
      # ======================

      neigh <- species1_net[ortho$Species1[i],]
      neigh <- names(neigh[neigh >= species1_thr])

      ortho_neigh <- species2_net[ortho$Species2[i],]
      ortho_neigh <- names(ortho_neigh[ortho_neigh >= species2_thr])
      ortho_neigh <- unique(ortho$Species1[ortho$Species2 %in% ortho_neigh])

      m <- length(neigh)
      n <- N1 - m
      k <- length(ortho_neigh)
      x <- length(intersect(neigh, ortho_neigh))
      p_val_1 <- 1
      effect_size_1 <- 1
      if (x > 1) {
        p_val_1 <- phyper(x-1, m, n, k, lower.tail = FALSE)
        effect_size_1 <- (x/k) / (m/N1)
      }

      # Species 2 -> Species 1
      # ======================

      neigh <- species2_net[ortho$Species2[i],]
      neigh <- names(neigh[neigh >= species2_thr])

      ortho_neigh <- species1_net[ortho$Species1[i],]
      ortho_neigh <- names(ortho_neigh[ortho_neigh >= species1_thr])
      ortho_neigh <- unique(ortho$Species2[ortho$Species1 %in% ortho_neigh])

      m2 <- length(neigh)
      n2 <- N2 - m2
      k2 <- length(ortho_neigh)
      x2 <- length(intersect(neigh, ortho_neigh))
      p_val_2 <- 1
      effect_size_2 <- 1
      if (x2 > 1) {
        p_val_2 <- phyper(x2-1, m2, n2, k2, lower.tail = FALSE)
        effect_size_2 <- (x2/k2) / (m2/N2)
      }

      # Return results as single row tibble
      tibble(
        OrthoGroup = ortho$OrthoGroup[i],
        Species1 = ortho$Species1[i],
        Species2 = ortho$Species2[i],
        Species1.neigh = m,
        Species1.ortho.neigh = k,
        Species1.neigh.overlap = x,
        Species1.p.val = p_val_1,
        Species1.effect.size = effect_size_1,
        Species2.neigh = m2,
        Species2.ortho.neigh = k2,
        Species2.neigh.overlap = x2,
        Species2.p.val = p_val_2,
        Species2.effect.size = effect_size_2
      )

    }, .progress = TRUE, .options = furrr_options(seed = TRUE))

  comparison_elapsed <- as.numeric(difftime(Sys.time(), comparison_start, units = "mins"))
  cat("\n✓ Network comparison completed in", round(comparison_elapsed, 2), "minutes\n")
  cat("  Average:", round(comparison_elapsed * 60 / nrow(ortho), 3), "seconds per ortholog pair\n\n")

  # Save results
  cat("Saving results to:", comparison_RData, "\n")
  save(comparison, species1_thr, species2_thr, file = comparison_RData)

  total_elapsed <- as.numeric(difftime(Sys.time(), start_time, units = "mins"))
  cat("\n")
  cat("=" * 60, "\n")
  cat("TOTAL ANALYSIS TIME:", round(total_elapsed, 2), "minutes\n")
  cat("=" * 60, "\n\n")
}

# Filter orthologs not in the networks
comparison <- comparison %>%
  filter(Species1.neigh.overlap > 0 & Species2.neigh.overlap > 0)

# FDR correction
comparison$Species1.p.val <- p.adjust(comparison$Species1.p.val, method = "fdr")
comparison$Species2.p.val <- p.adjust(comparison$Species2.p.val, method = "fdr")

cat ("After filtering on gene pairs in the networks:\n",
     " ", length(unique(comparison$OrthoGroup)), " ortholog groups containing: \n",
     "  ", length(unique(comparison$Species1)), " ", species1_name, " genes\n",
     "  ", length(unique(comparison$Species2)), " ", species2_name, " genes\n",
     sep = "")

# Comparison of p-values of orthologs: species 1 -> species 2 vs species 2 -> species 1
R <- cor.test(-log10(comparison$Species1.p.val + 1e-100), -log10(comparison$Species2.p.val + 1e-100), method = cor_method, continuity = TRUE)

data.frame(s1 = -log10(comparison$Species1.p.val),
           s2 = -log10(comparison$Species2.p.val)) %>%
  ggplot(aes(x = s1, y = s2)) +
  xlab(paste0(species1_name, " p-value (-log10)")) +
  ylab(paste0(species2_name, " p-value (-log10)")) +
  geom_point() +
  geom_smooth(method=lm, formula = y ~ x, fill = "gainsboro") +
  ggtitle(paste0("Correlation = ", format(R$estimate, digits = 3)))

# Comparison of p-values and effect sizes
comparison %>%
  rowwise() %>%
  mutate(Max.p.val = max(Species1.p.val, Species2.p.val)) %>%
  mutate(Min.effect.size = min(Species1.effect.size, Species2.effect.size)) %>%
  mutate(NeighborhoodSize = mean(c(Species1.neigh,Species2.neigh))) %>%
  filter(Max.p.val < 0.05) %>%
  ggplot(aes(x = -log10(Max.p.val), y = Min.effect.size, col = NeighborhoodSize)) +
  xlab("P-value") +
  ylab("Effect size") +
  geom_point()

# Print some summary statistics
# =============================

# Gene pairs

cat("GENE PAIRS:\n",
    sum(comparison$Species1.p.val< 0.05), " conserved ", species1_name, " gene pairs (",
    format(sum(comparison$Species1.p.val< 0.05)/nrow(comparison), digits = 3), ")\n",
    sum(comparison$Species2.p.val< 0.05), " conserved ", species2_name, " gene pairs (",
    format(sum(comparison$Species2.p.val< 0.05)/nrow(comparison), digits = 3), ")\n",
    sum(comparison$Species1.p.val< 0.05 & comparison$Species2.p.val< 0.05), " reciprocally conserved gene pairs (",
    format(sum(comparison$Species1.p.val< 0.05 & comparison$Species2.p.val< 0.05)/nrow(comparison), digits = 3), ")\n", sep = "")

# Genes

comparison_species1 <- comparison %>%
  group_by(Species1) %>%
  arrange(Species1.p.val) %>%
  slice(1)

comparison_species2 <- comparison %>%
  group_by(Species2) %>%
  arrange(Species2.p.val) %>%
  slice(1)

comparison_species1_12 <- comparison %>%
  rowwise() %>%
  mutate(Max.p.val = max(Species1.p.val, Species2.p.val)) %>%
  group_by(Species1) %>%
  arrange(Max.p.val) %>%
  slice(1)

comparison_species2_12 <- comparison %>%
  rowwise() %>%
  mutate(Max.p.val = max(Species1.p.val, Species2.p.val)) %>%
  group_by(Species2) %>%
  arrange(Max.p.val) %>%
  slice(1)

cat("GENES:\n",
    sum(comparison_species1$Species1.p.val< 0.05), " conserved ", species1_name, " genes (",
    format(sum(comparison_species1$Species1.p.val< 0.05)/nrow(comparison_species1), digits = 3), ")\n",
    sum(comparison_species2$Species2.p.val< 0.05), " conserved ", species2_name, " genes (",
    format(sum(comparison_species2$Species2.p.val< 0.05)/nrow(comparison_species2), digits = 3), ")\n",
    sum(comparison_species1_12$Max.p.val< 0.05), " reciprocally conserved ", species1_name, " genes (",
    format(sum(comparison_species1_12$Max.p.val< 0.05 &
               comparison_species1_12$Max.p.val< 0.05)/nrow(comparison_species1_12), digits = 3), ")\n",
    sum(comparison_species2_12$Max.p.val< 0.05), " reciprocally conserved ", species2_name, " genes (",
    format(sum(comparison_species2_12$Max.p.val< 0.05 &
               comparison_species2_12$Max.p.val< 0.05)/nrow(comparison_species2_12), digits = 3), ")\n",
    sep = "")

# Orthogroups

comparison_species1 <- comparison %>%
  group_by(OrthoGroup) %>%
  arrange(Species1.p.val) %>%
  slice(1)

comparison_species2 <- comparison %>%
  group_by(OrthoGroup) %>%
  arrange(Species2.p.val) %>%
  slice(1)

comparison_species12 <- comparison %>%
  rowwise() %>%
  mutate(Max.p.val = max(Species1.p.val, Species2.p.val)) %>%
  group_by(OrthoGroup) %>%
  arrange(Max.p.val) %>%
  slice(1)

cat("ORTHOLOG GROUPS:\n",
    sum(comparison_species1$Species1.p.val< 0.05), " conserved ", species1_name, " orthogroups (",
    format(sum(comparison_species1$Species1.p.val< 0.05)/nrow(comparison_species1), digits = 3), ")\n",
    sum(comparison_species2$Species2.p.val< 0.05), " conserved ", species2_name, " orthogroups (",
    format(sum(comparison_species2$Species2.p.val< 0.05)/nrow(comparison_species2), digits = 3), ")\n",
    sum(comparison_species12$Max.p.val< 0.05), " reciprocally conserved orthogroups (",
    format(sum(comparison_species12$Max.p.val< 0.05 &
               comparison_species12$Max.p.val< 0.05)/nrow(comparison_species12), digits = 3), ")\n", sep = "")

```

Table of all comparisons.

```{r, genepairs, warning=FALSE, error=FALSE, message=FALSE}

comparison_table <- comparison %>%
  rowwise() %>%
  mutate(Max.p.val = max(Species1.p.val, Species2.p.val)) %>%
  mutate(Min.effect.size = min(Species1.effect.size, Species2.effect.size)) %>%
  #left_join(potri_annot, by = "Species1") %>%
  select(-c("Species1.neigh", "Species1.ortho.neigh", "Species2.neigh", "Species2.ortho.neigh")) %>%
  arrange(Max.p.val)

comparison_table$Species1.p.val <- format(comparison_table$Species1.p.val, digits = 3, scientific = TRUE)
comparison_table$Species1.effect.size <- format(comparison_table$Species1.effect.size, digits = 1, scientific = FALSE)
comparison_table$Species2.p.val <- format(comparison_table$Species2.p.val, digits = 3, scientific = TRUE)
comparison_table$Species2.effect.size <- format(comparison_table$Species2.effect.size, digits = 1, scientific = FALSE)
comparison_table$Max.p.val <- format(comparison_table$Max.p.val, digits = 3, scientific = TRUE)
comparison_table$Min.effect.size <- format(comparison_table$Min.effect.size, digits = 1, scientific = FALSE)

datatable(comparison_table, rownames = FALSE, filter = "top",
          options = list(
            columnDefs = list(list(className = 'dt-center', targets = "_all"))
            )
          )

```

